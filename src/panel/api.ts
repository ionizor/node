/* tslint:disable */
/* eslint-disable */
/**
 * ionizor openapi docs
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.2.0:813ad884b2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig as RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountAction
 */
export interface AccountAction {
    /**
     * 
     * @type {number}
     * @memberof AccountAction
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AccountAction
     */
    'event': string;
    /**
     * 
     * @type {object}
     * @memberof AccountAction
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof AccountAction
     */
    'logged': string;
    /**
     * 
     * @type {string}
     * @memberof AccountAction
     */
    'ipAddress': string;
    /**
     * 
     * @type {string}
     * @memberof AccountAction
     */
    'userAgent': string;
    /**
     * 
     * @type {PublicUser}
     * @memberof AccountAction
     */
    'user': PublicUser | null;
}
/**
 * 
 * @export
 * @interface ApiAdminGet200Response
 */
export interface ApiAdminGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiAdminGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiAdminGet200ResponseStats}
     * @memberof ApiAdminGet200Response
     */
    'stats': ApiAdminGet200ResponseStats;
}
/**
 * 
 * @export
 * @interface ApiAdminGet200ResponseStats
 */
export interface ApiAdminGet200ResponseStats {
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStats
     */
    'totalBalance': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStats
     */
    'users': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStats
     */
    'users2FA': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStats
     */
    'rateLimits': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStats
     */
    'nodes': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStats
     */
    'servers': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStats
     */
    'accountActionLogs': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStats
     */
    'serverActionLogs': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStats
     */
    'apiKeys': number;
    /**
     * 
     * @type {ApiAdminGet200ResponseStatsInvoices}
     * @memberof ApiAdminGet200ResponseStats
     */
    'invoices': ApiAdminGet200ResponseStatsInvoices;
    /**
     * 
     * @type {ApiAdminGet200ResponseStatsConnections}
     * @memberof ApiAdminGet200ResponseStats
     */
    'connections': ApiAdminGet200ResponseStatsConnections;
}
/**
 * 
 * @export
 * @interface ApiAdminGet200ResponseStatsConnections
 */
export interface ApiAdminGet200ResponseStatsConnections {
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStatsConnections
     */
    'google': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStatsConnections
     */
    'github': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStatsConnections
     */
    'discord': number;
}
/**
 * 
 * @export
 * @interface ApiAdminGet200ResponseStatsInvoices
 */
export interface ApiAdminGet200ResponseStatsInvoices {
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStatsInvoices
     */
    'cancelled': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStatsInvoices
     */
    'unpaid': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminGet200ResponseStatsInvoices
     */
    'paid': number;
}
/**
 * 
 * @export
 * @interface ApiAdminPollsGet200Response
 */
export interface ApiAdminPollsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiAdminPollsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseList}
     * @memberof ApiAdminPollsGet200Response
     */
    'list': ApiAdminPollsGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiAdminPollsGet200ResponseList
 */
export interface ApiAdminPollsGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiAdminPollsGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<Poll>}
     * @memberof ApiAdminPollsGet200ResponseList
     */
    'data': Array<Poll>;
}
/**
 * 
 * @export
 * @interface ApiAdminPollsGet200ResponseListMeta
 */
export interface ApiAdminPollsGet200ResponseListMeta {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMetaItems}
     * @memberof ApiAdminPollsGet200ResponseListMeta
     */
    'items': ApiAdminPollsGet200ResponseListMetaItems;
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMetaPages}
     * @memberof ApiAdminPollsGet200ResponseListMeta
     */
    'pages': ApiAdminPollsGet200ResponseListMetaPages;
}
/**
 * 
 * @export
 * @interface ApiAdminPollsGet200ResponseListMetaItems
 */
export interface ApiAdminPollsGet200ResponseListMetaItems {
    /**
     * 
     * @type {number}
     * @memberof ApiAdminPollsGet200ResponseListMetaItems
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminPollsGet200ResponseListMetaItems
     */
    'perPage': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminPollsGet200ResponseListMetaItems
     */
    'current': number;
}
/**
 * 
 * @export
 * @interface ApiAdminPollsGet200ResponseListMetaPages
 */
export interface ApiAdminPollsGet200ResponseListMetaPages {
    /**
     * 
     * @type {number}
     * @memberof ApiAdminPollsGet200ResponseListMetaPages
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof ApiAdminPollsGet200ResponseListMetaPages
     */
    'current': number;
}
/**
 * 
 * @export
 * @interface ApiAdminPollsPollPatchRequest
 */
export interface ApiAdminPollsPollPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiAdminPollsPollPatchRequest
     */
    'title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiAdminPollsPollPatchRequest
     */
    'multiSelect'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiAdminPollsPollPatchRequest
     */
    'open'?: boolean;
    /**
     * 
     * @type {Array<ApiAdminPollsPostRequestOptionsInner>}
     * @memberof ApiAdminPollsPollPatchRequest
     */
    'options'?: Array<ApiAdminPollsPostRequestOptionsInner>;
}
/**
 * 
 * @export
 * @interface ApiAdminPollsPost200Response
 */
export interface ApiAdminPollsPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiAdminPollsPost200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiAdminPollsPostRequest
 */
export interface ApiAdminPollsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiAdminPollsPostRequest
     */
    'title': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiAdminPollsPostRequest
     */
    'multiSelect': boolean;
    /**
     * 
     * @type {Array<ApiAdminPollsPostRequestOptionsInner>}
     * @memberof ApiAdminPollsPostRequest
     */
    'options': Array<ApiAdminPollsPostRequestOptionsInner>;
}
/**
 * 
 * @export
 * @interface ApiAdminPollsPostRequestOptionsInner
 */
export interface ApiAdminPollsPostRequestOptionsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiAdminPollsPostRequestOptionsInner
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ApiAdminTicketsGet200Response
 */
export interface ApiAdminTicketsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiAdminTicketsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiAdminTicketsGet200ResponseList}
     * @memberof ApiAdminTicketsGet200Response
     */
    'list': ApiAdminTicketsGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiAdminTicketsGet200ResponseList
 */
export interface ApiAdminTicketsGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiAdminTicketsGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<Ticket>}
     * @memberof ApiAdminTicketsGet200ResponseList
     */
    'data': Array<Ticket>;
}
/**
 * 
 * @export
 * @interface ApiInfosGet200Response
 */
export interface ApiInfosGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiInfosGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiInfosGet200ResponseInfos}
     * @memberof ApiInfosGet200Response
     */
    'infos': ApiInfosGet200ResponseInfos;
    /**
     * 
     * @type {ApiInfosGet200ResponseStats}
     * @memberof ApiInfosGet200Response
     */
    'stats': ApiInfosGet200ResponseStats;
}
/**
 * 
 * @export
 * @interface ApiInfosGet200ResponseInfos
 */
export interface ApiInfosGet200ResponseInfos {
    /**
     * 
     * @type {string}
     * @memberof ApiInfosGet200ResponseInfos
     */
    'appVersion': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInfosGet200ResponseInfos
     */
    'nodeVersion': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInfosGet200ResponseInfos
     */
    'postgresVersion': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInfosGet200ResponseInfos
     */
    'redisVersion': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInfosGet200ResponseInfos
     */
    'deployment': string;
    /**
     * 
     * @type {number}
     * @memberof ApiInfosGet200ResponseInfos
     */
    'uptime': number;
}
/**
 * 
 * @export
 * @interface ApiInfosGet200ResponseStats
 */
export interface ApiInfosGet200ResponseStats {
    /**
     * 
     * @type {number}
     * @memberof ApiInfosGet200ResponseStats
     */
    'users': number;
    /**
     * 
     * @type {number}
     * @memberof ApiInfosGet200ResponseStats
     */
    'nodes': number;
    /**
     * 
     * @type {number}
     * @memberof ApiInfosGet200ResponseStats
     */
    'servers': number;
    /**
     * 
     * @type {number}
     * @memberof ApiInfosGet200ResponseStats
     */
    'storedData': number;
}
/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * 
     * @type {number}
     * @memberof ApiKey
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ApiKey
     */
    'requests': number;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'key'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiKey
     */
    'generalPermissions': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiKey
     */
    'serverPermissions': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'used': string | null;
}
/**
 * 
 * @export
 * @interface ApiNodeInfosGet200Response
 */
export interface ApiNodeInfosGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiNodeInfosGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Node}
     * @memberof ApiNodeInfosGet200Response
     */
    'node': Node;
    /**
     * 
     * @type {string}
     * @memberof ApiNodeInfosGet200Response
     */
    'secret': string;
}
/**
 * 
 * @export
 * @interface ApiNodeServerServerAllocationsGet200Response
 */
export interface ApiNodeServerServerAllocationsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiNodeServerServerAllocationsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Array<ApiNodeServerServerAllocationsGet200ResponseAllocationsInner>}
     * @memberof ApiNodeServerServerAllocationsGet200Response
     */
    'allocations': Array<ApiNodeServerServerAllocationsGet200ResponseAllocationsInner>;
}
/**
 * 
 * @export
 * @interface ApiNodeServerServerAllocationsGet200ResponseAllocationsInner
 */
export interface ApiNodeServerServerAllocationsGet200ResponseAllocationsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiNodeServerServerAllocationsGet200ResponseAllocationsInner
     */
    'ip': string | null;
    /**
     * 
     * @type {ApiNodeServerServerAllocationsGet200ResponseAllocationsInnerPort}
     * @memberof ApiNodeServerServerAllocationsGet200ResponseAllocationsInner
     */
    'port': ApiNodeServerServerAllocationsGet200ResponseAllocationsInnerPort;
}
/**
 * 
 * @export
 * @interface ApiNodeServerServerAllocationsGet200ResponseAllocationsInnerPort
 */
export interface ApiNodeServerServerAllocationsGet200ResponseAllocationsInnerPort {
    /**
     * 
     * @type {number}
     * @memberof ApiNodeServerServerAllocationsGet200ResponseAllocationsInnerPort
     */
    'external': number;
    /**
     * 
     * @type {number}
     * @memberof ApiNodeServerServerAllocationsGet200ResponseAllocationsInnerPort
     */
    'internal': number;
}
/**
 * 
 * @export
 * @interface ApiNodeServerServerFilesPullPostRequest
 */
export interface ApiNodeServerServerFilesPullPostRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiNodeServerServerFilesPullPostRequest
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ApiNodeServerServerFilesPullPostRequest
     */
    'progress': number;
    /**
     * 
     * @type {number}
     * @memberof ApiNodeServerServerFilesPullPostRequest
     */
    'size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ApiNodeServerServerFilesPullPostRequest
     */
    'done': boolean;
}
/**
 * 
 * @export
 * @interface ApiNodeServerServerSshPost200Response
 */
export interface ApiNodeServerServerSshPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiNodeServerServerSshPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiNodeServerServerSshPost200Response
     */
    'ssh': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiNodeServerServerSshPost200Response
     */
    'sftp': boolean;
}
/**
 * 
 * @export
 * @interface ApiNodeServerServerSshPostRequest
 */
export interface ApiNodeServerServerSshPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiNodeServerServerSshPostRequest
     */
    'handle': string;
    /**
     * 
     * @type {ApiNodeServerServerSshPostRequestAuth}
     * @memberof ApiNodeServerServerSshPostRequest
     */
    'auth': ApiNodeServerServerSshPostRequestAuth;
}
/**
 * 
 * @export
 * @interface ApiNodeServerServerSshPostRequestAuth
 */
export interface ApiNodeServerServerSshPostRequestAuth {
    /**
     * 
     * @type {string}
     * @memberof ApiNodeServerServerSshPostRequestAuth
     */
    'type': ApiNodeServerServerSshPostRequestAuthTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiNodeServerServerSshPostRequestAuth
     */
    'value': string;
}

export const ApiNodeServerServerSshPostRequestAuthTypeEnum = {
    Password: 'password',
    Key: 'key'
} as const;

export type ApiNodeServerServerSshPostRequestAuthTypeEnum = typeof ApiNodeServerServerSshPostRequestAuthTypeEnum[keyof typeof ApiNodeServerServerSshPostRequestAuthTypeEnum];

/**
 * 
 * @export
 * @interface ApiNodeServerServerStatePostRequest
 */
export interface ApiNodeServerServerStatePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiNodeServerServerStatePostRequest
     */
    'state': ApiNodeServerServerStatePostRequestStateEnum;
}

export const ApiNodeServerServerStatePostRequestStateEnum = {
    Neutral: 'NEUTRAL',
    Configuring: 'CONFIGURING',
    Installing: 'INSTALLING',
    BackingUp: 'BACKING_UP',
    Restoring: 'RESTORING'
} as const;

export type ApiNodeServerServerStatePostRequestStateEnum = typeof ApiNodeServerServerStatePostRequestStateEnum[keyof typeof ApiNodeServerServerStatePostRequestStateEnum];

/**
 * 
 * @export
 * @interface ApiPermissionsGet200Response
 */
export interface ApiPermissionsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiPermissionsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiPermissionsGet200ResponsePermissions}
     * @memberof ApiPermissionsGet200Response
     */
    'permissions': ApiPermissionsGet200ResponsePermissions;
}
/**
 * 
 * @export
 * @interface ApiPermissionsGet200ResponsePermissions
 */
export interface ApiPermissionsGet200ResponsePermissions {
    /**
     * 
     * @type {Permissions}
     * @memberof ApiPermissionsGet200ResponsePermissions
     */
    'general': Permissions;
    /**
     * 
     * @type {Permissions}
     * @memberof ApiPermissionsGet200ResponsePermissions
     */
    'server': Permissions;
}
/**
 * 
 * @export
 * @interface ApiPollsPollGet200Response
 */
export interface ApiPollsPollGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiPollsPollGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Poll}
     * @memberof ApiPollsPollGet200Response
     */
    'poll': Poll;
}
/**
 * 
 * @export
 * @interface ApiServerServerActionLogsGet200Response
 */
export interface ApiServerServerActionLogsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerActionLogsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiServerServerActionLogsGet200ResponseList}
     * @memberof ApiServerServerActionLogsGet200Response
     */
    'list': ApiServerServerActionLogsGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiServerServerActionLogsGet200ResponseList
 */
export interface ApiServerServerActionLogsGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiServerServerActionLogsGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<ServerAction>}
     * @memberof ApiServerServerActionLogsGet200ResponseList
     */
    'data': Array<ServerAction>;
}
/**
 * 
 * @export
 * @interface ApiServerServerAllocationsAllocationPatchRequest
 */
export interface ApiServerServerAllocationsAllocationPatchRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerAllocationsAllocationPatchRequest
     */
    'port'?: number;
}
/**
 * 
 * @export
 * @interface ApiServerServerAllocationsAutocompleteGet200Response
 */
export interface ApiServerServerAllocationsAutocompleteGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerAllocationsAutocompleteGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Array<ApiServerServerAllocationsAutocompleteGet200ResponseAllocationsInner>}
     * @memberof ApiServerServerAllocationsAutocompleteGet200Response
     */
    'allocations': Array<ApiServerServerAllocationsAutocompleteGet200ResponseAllocationsInner>;
}
/**
 * 
 * @export
 * @interface ApiServerServerAllocationsAutocompleteGet200ResponseAllocationsInner
 */
export interface ApiServerServerAllocationsAutocompleteGet200ResponseAllocationsInner {
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerAllocationsAutocompleteGet200ResponseAllocationsInner
     */
    'id': number;
    /**
     * 
     * @type {ApiServerServerAllocationsAutocompleteGet200ResponseAllocationsInnerIp}
     * @memberof ApiServerServerAllocationsAutocompleteGet200ResponseAllocationsInner
     */
    'ip': ApiServerServerAllocationsAutocompleteGet200ResponseAllocationsInnerIp | null;
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerAllocationsAutocompleteGet200ResponseAllocationsInner
     */
    'port': number;
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerAllocationsAutocompleteGet200ResponseAllocationsInner
     */
    'used': boolean;
}
/**
 * @type ApiServerServerAllocationsAutocompleteGet200ResponseAllocationsInnerIp
 * @export
 */
export type ApiServerServerAllocationsAutocompleteGet200ResponseAllocationsInnerIp = string;

/**
 * 
 * @export
 * @interface ApiServerServerAllocationsGet200Response
 */
export interface ApiServerServerAllocationsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerAllocationsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiServerServerAllocationsGet200ResponseList}
     * @memberof ApiServerServerAllocationsGet200Response
     */
    'list': ApiServerServerAllocationsGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiServerServerAllocationsGet200ResponseList
 */
export interface ApiServerServerAllocationsGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiServerServerAllocationsGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<ServerAllocation>}
     * @memberof ApiServerServerAllocationsGet200ResponseList
     */
    'data': Array<ServerAllocation>;
}
/**
 * 
 * @export
 * @interface ApiServerServerAllocationsPost200Response
 */
export interface ApiServerServerAllocationsPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerAllocationsPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ServerAllocation}
     * @memberof ApiServerServerAllocationsPost200Response
     */
    'allocation': ServerAllocation;
}
/**
 * 
 * @export
 * @interface ApiServerServerAllocationsPostRequest
 */
export interface ApiServerServerAllocationsPostRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerAllocationsPostRequest
     */
    'port': number;
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerAllocationsPostRequest
     */
    'allocation': number;
}
/**
 * 
 * @export
 * @interface ApiServerServerFilesArchivesGet200Response
 */
export interface ApiServerServerFilesArchivesGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerFilesArchivesGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Array<ServerFileArchive>}
     * @memberof ApiServerServerFilesArchivesGet200Response
     */
    'archives': Array<ServerFileArchive>;
}
/**
 * 
 * @export
 * @interface ApiServerServerFilesArchivesPost200Response
 */
export interface ApiServerServerFilesArchivesPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerFilesArchivesPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ServerFileArchive}
     * @memberof ApiServerServerFilesArchivesPost200Response
     */
    'archive': ServerFileArchive;
}
/**
 * 
 * @export
 * @interface ApiServerServerFilesArchivesPostRequest
 */
export interface ApiServerServerFilesArchivesPostRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiServerServerFilesArchivesPostRequest
     */
    'paths': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerFilesArchivesPostRequest
     */
    'type': ApiServerServerFilesArchivesPostRequestTypeEnum;
}

export const ApiServerServerFilesArchivesPostRequestTypeEnum = {
    Zip: 'zip',
    Tar: 'tar'
} as const;

export type ApiServerServerFilesArchivesPostRequestTypeEnum = typeof ApiServerServerFilesArchivesPostRequestTypeEnum[keyof typeof ApiServerServerFilesArchivesPostRequestTypeEnum];

/**
 * 
 * @export
 * @interface ApiServerServerFilesDeletePost200Response
 */
export interface ApiServerServerFilesDeletePost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerFilesDeletePost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerFilesDeletePost200Response
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface ApiServerServerFilesDeletePostRequest
 */
export interface ApiServerServerFilesDeletePostRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiServerServerFilesDeletePostRequest
     */
    'paths': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiServerServerFilesGet200Response
 */
export interface ApiServerServerFilesGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerFilesGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Array<ApiServerServerFilesGet200ResponseFilesInner>}
     * @memberof ApiServerServerFilesGet200Response
     */
    'files': Array<ApiServerServerFilesGet200ResponseFilesInner>;
}
/**
 * @type ApiServerServerFilesGet200ResponseFilesInner
 * @export
 */
export type ApiServerServerFilesGet200ResponseFilesInner = ApiServerServerFilesGet200ResponseFilesInnerOneOf | ApiServerServerFilesGet200ResponseFilesInnerOneOf1;

/**
 * 
 * @export
 * @interface ApiServerServerFilesGet200ResponseFilesInnerOneOf
 */
export interface ApiServerServerFilesGet200ResponseFilesInnerOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerFilesGet200ResponseFilesInnerOneOf
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerFilesGet200ResponseFilesInnerOneOf
     */
    'type': ApiServerServerFilesGet200ResponseFilesInnerOneOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerFilesGet200ResponseFilesInnerOneOf
     */
    'modified': string;
}

export const ApiServerServerFilesGet200ResponseFilesInnerOneOfTypeEnum = {
    Directory: 'directory'
} as const;

export type ApiServerServerFilesGet200ResponseFilesInnerOneOfTypeEnum = typeof ApiServerServerFilesGet200ResponseFilesInnerOneOfTypeEnum[keyof typeof ApiServerServerFilesGet200ResponseFilesInnerOneOfTypeEnum];

/**
 * 
 * @export
 * @interface ApiServerServerFilesGet200ResponseFilesInnerOneOf1
 */
export interface ApiServerServerFilesGet200ResponseFilesInnerOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerFilesGet200ResponseFilesInnerOneOf1
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerFilesGet200ResponseFilesInnerOneOf1
     */
    'type': ApiServerServerFilesGet200ResponseFilesInnerOneOf1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerFilesGet200ResponseFilesInnerOneOf1
     */
    'modified': string;
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerFilesGet200ResponseFilesInnerOneOf1
     */
    'size': number;
}

export const ApiServerServerFilesGet200ResponseFilesInnerOneOf1TypeEnum = {
    File: 'file'
} as const;

export type ApiServerServerFilesGet200ResponseFilesInnerOneOf1TypeEnum = typeof ApiServerServerFilesGet200ResponseFilesInnerOneOf1TypeEnum[keyof typeof ApiServerServerFilesGet200ResponseFilesInnerOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface ApiServerServerFilesHashGet200Response
 */
export interface ApiServerServerFilesHashGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerFilesHashGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiServerServerFilesHashGet200ResponseHashes}
     * @memberof ApiServerServerFilesHashGet200Response
     */
    'hashes': ApiServerServerFilesHashGet200ResponseHashes;
}
/**
 * 
 * @export
 * @interface ApiServerServerFilesHashGet200ResponseHashes
 */
export interface ApiServerServerFilesHashGet200ResponseHashes {
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerFilesHashGet200ResponseHashes
     */
    'sha1': string;
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerFilesHashGet200ResponseHashes
     */
    'sha256': string;
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerFilesHashGet200ResponseHashes
     */
    'sha512': string;
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerFilesHashGet200ResponseHashes
     */
    'md5': string;
}
/**
 * 
 * @export
 * @interface ApiServerServerFilesPullsGet200Response
 */
export interface ApiServerServerFilesPullsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerFilesPullsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Array<ServerFilePull>}
     * @memberof ApiServerServerFilesPullsGet200Response
     */
    'pulls': Array<ServerFilePull>;
}
/**
 * 
 * @export
 * @interface ApiServerServerFilesPullsPost200Response
 */
export interface ApiServerServerFilesPullsPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerFilesPullsPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ServerFilePull}
     * @memberof ApiServerServerFilesPullsPost200Response
     */
    'pull': ServerFilePull;
}
/**
 * 
 * @export
 * @interface ApiServerServerFilesPullsPostRequest
 */
export interface ApiServerServerFilesPullsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerFilesPullsPostRequest
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ApiServerServerFilesPullsPullDelete200Response
 */
export interface ApiServerServerFilesPullsPullDelete200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerFilesPullsPullDelete200Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface ApiServerServerGet200Response
 */
export interface ApiServerServerGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Server}
     * @memberof ApiServerServerGet200Response
     */
    'server': Server;
}
/**
 * 
 * @export
 * @interface ApiServerServerIconPost200Response
 */
export interface ApiServerServerIconPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerIconPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerIconPost200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ApiServerServerPatchRequest
 */
export interface ApiServerServerPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerPatchRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerPatchRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ApiServerServerResourcesDiskPatchRequest
 */
export interface ApiServerServerResourcesDiskPatchRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerResourcesDiskPatchRequest
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface ApiServerServerResourcesPatchRequest
 */
export interface ApiServerServerResourcesPatchRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerResourcesPatchRequest
     */
    'cpu'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerResourcesPatchRequest
     */
    'memory'?: number;
}
/**
 * 
 * @export
 * @interface ApiServerServerSshGet200Response
 */
export interface ApiServerServerSshGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerSshGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiServerServerSshGet200ResponseInfos}
     * @memberof ApiServerServerSshGet200Response
     */
    'infos': ApiServerServerSshGet200ResponseInfos;
}
/**
 * 
 * @export
 * @interface ApiServerServerSshGet200ResponseInfos
 */
export interface ApiServerServerSshGet200ResponseInfos {
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerSshGet200ResponseInfos
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerSshGet200ResponseInfos
     */
    'hostname': string;
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerSshGet200ResponseInfos
     */
    'port': number;
}
/**
 * 
 * @export
 * @interface ApiServerServerStatsGet200Response
 */
export interface ApiServerServerStatsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerStatsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiServerServerStatsGet200ResponseStats}
     * @memberof ApiServerServerStatsGet200Response
     */
    'stats': ApiServerServerStatsGet200ResponseStats;
}
/**
 * 
 * @export
 * @interface ApiServerServerStatsGet200ResponseStats
 */
export interface ApiServerServerStatsGet200ResponseStats {
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerStatsGet200ResponseStats
     */
    'status': ApiServerServerStatsGet200ResponseStatsStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerStatsGet200ResponseStats
     */
    'cpu': number;
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerStatsGet200ResponseStats
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof ApiServerServerStatsGet200ResponseStats
     */
    'disk': number;
}

export const ApiServerServerStatsGet200ResponseStatsStatusEnum = {
    Running: 'RUNNING',
    Stopped: 'STOPPED',
    Error: 'ERROR',
    Frozen: 'FROZEN'
} as const;

export type ApiServerServerStatsGet200ResponseStatsStatusEnum = typeof ApiServerServerStatsGet200ResponseStatsStatusEnum[keyof typeof ApiServerServerStatsGet200ResponseStatsStatusEnum];

/**
 * 
 * @export
 * @interface ApiServerServerStatusPostRequest
 */
export interface ApiServerServerStatusPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerStatusPostRequest
     */
    'status'?: ApiServerServerStatusPostRequestStatusEnum;
}

export const ApiServerServerStatusPostRequestStatusEnum = {
    Start: 'START',
    Restart: 'RESTART',
    Stop: 'STOP'
} as const;

export type ApiServerServerStatusPostRequestStatusEnum = typeof ApiServerServerStatusPostRequestStatusEnum[keyof typeof ApiServerServerStatusPostRequestStatusEnum];

/**
 * 
 * @export
 * @interface ApiServerServerSubusersDeleteRequest
 */
export interface ApiServerServerSubusersDeleteRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiServerServerSubusersDeleteRequest
     */
    'items': Array<number>;
}
/**
 * 
 * @export
 * @interface ApiServerServerSubusersGet200Response
 */
export interface ApiServerServerSubusersGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerSubusersGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiServerServerSubusersGet200ResponseList}
     * @memberof ApiServerServerSubusersGet200Response
     */
    'list': ApiServerServerSubusersGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiServerServerSubusersGet200ResponseList
 */
export interface ApiServerServerSubusersGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiServerServerSubusersGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<SubUser>}
     * @memberof ApiServerServerSubusersGet200ResponseList
     */
    'data': Array<SubUser>;
}
/**
 * 
 * @export
 * @interface ApiServerServerSubusersPost200Response
 */
export interface ApiServerServerSubusersPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiServerServerSubusersPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {SubUser}
     * @memberof ApiServerServerSubusersPost200Response
     */
    'subUser': SubUser;
}
/**
 * 
 * @export
 * @interface ApiServerServerSubusersPostRequest
 */
export interface ApiServerServerSubusersPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiServerServerSubusersPostRequest
     */
    'handle': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiServerServerSubusersPostRequest
     */
    'permissions': Array<number>;
}
/**
 * 
 * @export
 * @interface ApiServerServerSubusersSubuserPatchRequest
 */
export interface ApiServerServerSubusersSubuserPatchRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiServerServerSubusersSubuserPatchRequest
     */
    'permissions'?: Array<number>;
}
/**
 * 
 * @export
 * @interface ApiUser2faDeleteRequest
 */
export interface ApiUser2faDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUser2faDeleteRequest
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUser2faDeleteRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ApiUser2faGet200Response
 */
export interface ApiUser2faGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUser2faGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUser2faGet200ResponseTwoFactor}
     * @memberof ApiUser2faGet200Response
     */
    'twoFactor': ApiUser2faGet200ResponseTwoFactor;
}
/**
 * 
 * @export
 * @interface ApiUser2faGet200ResponseTwoFactor
 */
export interface ApiUser2faGet200ResponseTwoFactor {
    /**
     * 
     * @type {string}
     * @memberof ApiUser2faGet200ResponseTwoFactor
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUser2faGet200ResponseTwoFactor
     */
    'uri': string;
}
/**
 * 
 * @export
 * @interface ApiUser2faPost200Response
 */
export interface ApiUser2faPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUser2faPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiUser2faPost200Response
     */
    'resetKeys': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiUser2faPostRequest
 */
export interface ApiUser2faPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUser2faPostRequest
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUser2faPostRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ApiUserActionLogsGet200Response
 */
export interface ApiUserActionLogsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserActionLogsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserActionLogsGet200ResponseList}
     * @memberof ApiUserActionLogsGet200Response
     */
    'list': ApiUserActionLogsGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiUserActionLogsGet200ResponseList
 */
export interface ApiUserActionLogsGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiUserActionLogsGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<AccountAction>}
     * @memberof ApiUserActionLogsGet200ResponseList
     */
    'data': Array<AccountAction>;
}
/**
 * 
 * @export
 * @interface ApiUserApiKeysApiKeyPatchRequest
 */
export interface ApiUserApiKeysApiKeyPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserApiKeysApiKeyPatchRequest
     */
    'name'?: string;
    /**
     * 
     * @type {ApiUserApiKeysApiKeyPatchRequestPermissions}
     * @memberof ApiUserApiKeysApiKeyPatchRequest
     */
    'permissions'?: ApiUserApiKeysApiKeyPatchRequestPermissions;
}
/**
 * 
 * @export
 * @interface ApiUserApiKeysApiKeyPatchRequestPermissions
 */
export interface ApiUserApiKeysApiKeyPatchRequestPermissions {
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiUserApiKeysApiKeyPatchRequestPermissions
     */
    'general'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiUserApiKeysApiKeyPatchRequestPermissions
     */
    'server'?: Array<number>;
}
/**
 * 
 * @export
 * @interface ApiUserApiKeysApiKeyResetKeyPost200Response
 */
export interface ApiUserApiKeysApiKeyResetKeyPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserApiKeysApiKeyResetKeyPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiKey}
     * @memberof ApiUserApiKeysApiKeyResetKeyPost200Response
     */
    'key': ApiKey;
}
/**
 * 
 * @export
 * @interface ApiUserApiKeysGet200Response
 */
export interface ApiUserApiKeysGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserApiKeysGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserApiKeysGet200ResponseList}
     * @memberof ApiUserApiKeysGet200Response
     */
    'list': ApiUserApiKeysGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiUserApiKeysGet200ResponseList
 */
export interface ApiUserApiKeysGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiUserApiKeysGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<ApiKey>}
     * @memberof ApiUserApiKeysGet200ResponseList
     */
    'data': Array<ApiKey>;
}
/**
 * 
 * @export
 * @interface ApiUserApiKeysPostRequest
 */
export interface ApiUserApiKeysPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserApiKeysPostRequest
     */
    'name': string;
    /**
     * 
     * @type {ApiUserApiKeysPostRequestPermissions}
     * @memberof ApiUserApiKeysPostRequest
     */
    'permissions': ApiUserApiKeysPostRequestPermissions;
}
/**
 * 
 * @export
 * @interface ApiUserApiKeysPostRequestPermissions
 */
export interface ApiUserApiKeysPostRequestPermissions {
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiUserApiKeysPostRequestPermissions
     */
    'general': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiUserApiKeysPostRequestPermissions
     */
    'server': Array<number>;
}
/**
 * 
 * @export
 * @interface ApiUserConnectionsAppDeleteRequest
 */
export interface ApiUserConnectionsAppDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserConnectionsAppDeleteRequest
     */
    'app': ApiUserConnectionsAppDeleteRequestAppEnum;
}

export const ApiUserConnectionsAppDeleteRequestAppEnum = {
    Google: 'GOOGLE',
    Github: 'GITHUB',
    Discord: 'DISCORD'
} as const;

export type ApiUserConnectionsAppDeleteRequestAppEnum = typeof ApiUserConnectionsAppDeleteRequestAppEnum[keyof typeof ApiUserConnectionsAppDeleteRequestAppEnum];

/**
 * 
 * @export
 * @interface ApiUserConnectionsGet200Response
 */
export interface ApiUserConnectionsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserConnectionsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserConnectionsGet200ResponseList}
     * @memberof ApiUserConnectionsGet200Response
     */
    'list': ApiUserConnectionsGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiUserConnectionsGet200ResponseList
 */
export interface ApiUserConnectionsGet200ResponseList {
    /**
     * 
     * @type {ApiUserConnectionsGet200ResponseListGoogle}
     * @memberof ApiUserConnectionsGet200ResponseList
     */
    'google': ApiUserConnectionsGet200ResponseListGoogle;
    /**
     * 
     * @type {ApiUserConnectionsGet200ResponseListGoogle}
     * @memberof ApiUserConnectionsGet200ResponseList
     */
    'github': ApiUserConnectionsGet200ResponseListGoogle;
    /**
     * 
     * @type {ApiUserConnectionsGet200ResponseListGoogle}
     * @memberof ApiUserConnectionsGet200ResponseList
     */
    'discord': ApiUserConnectionsGet200ResponseListGoogle;
}
/**
 * @type ApiUserConnectionsGet200ResponseListGoogle
 * @export
 */
export type ApiUserConnectionsGet200ResponseListGoogle = ApiUserConnectionsGet200ResponseListGoogleOneOf | ApiUserConnectionsGet200ResponseListGoogleOneOf1;

/**
 * 
 * @export
 * @interface ApiUserConnectionsGet200ResponseListGoogleOneOf
 */
export interface ApiUserConnectionsGet200ResponseListGoogleOneOf {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserConnectionsGet200ResponseListGoogleOneOf
     */
    'linked': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiUserConnectionsGet200ResponseListGoogleOneOf
     */
    'avatar': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserConnectionsGet200ResponseListGoogleOneOf
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiUserConnectionsGet200ResponseListGoogleOneOf1
 */
export interface ApiUserConnectionsGet200ResponseListGoogleOneOf1 {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserConnectionsGet200ResponseListGoogleOneOf1
     */
    'linked': boolean;
}
/**
 * 
 * @export
 * @interface ApiUserEmailPatchRequest
 */
export interface ApiUserEmailPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserEmailPatchRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ApiUserEmailVerifyPostRequest
 */
export interface ApiUserEmailVerifyPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserEmailVerifyPostRequest
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface ApiUserFriendsDelete200Response
 */
export interface ApiUserFriendsDelete200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserFriendsDelete200Response
     */
    'success': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiUserFriendsDelete200Response
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface ApiUserFriendsDeleteRequest
 */
export interface ApiUserFriendsDeleteRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof ApiUserFriendsDeleteRequest
     */
    'items': Array<number>;
}
/**
 * 
 * @export
 * @interface ApiUserFriendsGet200Response
 */
export interface ApiUserFriendsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserFriendsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserFriendsGet200ResponseList}
     * @memberof ApiUserFriendsGet200Response
     */
    'list': ApiUserFriendsGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiUserFriendsGet200ResponseList
 */
export interface ApiUserFriendsGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiUserFriendsGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<Friend>}
     * @memberof ApiUserFriendsGet200ResponseList
     */
    'data': Array<Friend>;
}
/**
 * 
 * @export
 * @interface ApiUserInvoicesGet200Response
 */
export interface ApiUserInvoicesGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserInvoicesGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserInvoicesGet200ResponseList}
     * @memberof ApiUserInvoicesGet200Response
     */
    'list': ApiUserInvoicesGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiUserInvoicesGet200ResponseList
 */
export interface ApiUserInvoicesGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiUserInvoicesGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<Invoice>}
     * @memberof ApiUserInvoicesGet200ResponseList
     */
    'data': Array<Invoice>;
}
/**
 * 
 * @export
 * @interface ApiUserInvoicesInvoicePayPost200Response
 */
export interface ApiUserInvoicesInvoicePayPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserInvoicesInvoicePayPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiUserInvoicesInvoicePayPost200Response
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface ApiUserInvoicesInvoicePayPostRequest
 */
export interface ApiUserInvoicesInvoicePayPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserInvoicesInvoicePayPostRequest
     */
    'method': ApiUserInvoicesInvoicePayPostRequestMethodEnum;
}

export const ApiUserInvoicesInvoicePayPostRequestMethodEnum = {
    Paypal: 'paypal'
} as const;

export type ApiUserInvoicesInvoicePayPostRequestMethodEnum = typeof ApiUserInvoicesInvoicePayPostRequestMethodEnum[keyof typeof ApiUserInvoicesInvoicePayPostRequestMethodEnum];

/**
 * 
 * @export
 * @interface ApiUserInvoicesPost200Response
 */
export interface ApiUserInvoicesPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserInvoicesPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Invoice}
     * @memberof ApiUserInvoicesPost200Response
     */
    'invoice': Invoice;
}
/**
 * 
 * @export
 * @interface ApiUserInvoicesPostRequest
 */
export interface ApiUserInvoicesPostRequest {
    /**
     * 
     * @type {number}
     * @memberof ApiUserInvoicesPostRequest
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface ApiUserInvoicesStatsGet200Response
 */
export interface ApiUserInvoicesStatsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserInvoicesStatsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserInvoicesStatsGet200ResponseStats}
     * @memberof ApiUserInvoicesStatsGet200Response
     */
    'stats': ApiUserInvoicesStatsGet200ResponseStats;
}
/**
 * 
 * @export
 * @interface ApiUserInvoicesStatsGet200ResponseStats
 */
export interface ApiUserInvoicesStatsGet200ResponseStats {
    /**
     * 
     * @type {number}
     * @memberof ApiUserInvoicesStatsGet200ResponseStats
     */
    'balance': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserInvoicesStatsGet200ResponseStats
     */
    'paid': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserInvoicesStatsGet200ResponseStats
     */
    'pending': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserInvoicesStatsGet200ResponseStats
     */
    'cancelled': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserInvoicesStatsGet200ResponseStats
     */
    'pendingAmount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserInvoicesStatsGet200ResponseStats
     */
    'expire24h': number;
}
/**
 * 
 * @export
 * @interface ApiUserLogin2faPostRequest
 */
export interface ApiUserLogin2faPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserLogin2faPostRequest
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserLogin2faPostRequest
     */
    'code': string;
}
/**
 * @type ApiUserLoginPost200Response
 * @export
 */
export type ApiUserLoginPost200Response = ApiUserLoginPost200ResponseOneOf | ApiUserPost200Response;

/**
 * 
 * @export
 * @interface ApiUserLoginPost200ResponseOneOf
 */
export interface ApiUserLoginPost200ResponseOneOf {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserLoginPost200ResponseOneOf
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserLoginPost200ResponseOneOfInfos}
     * @memberof ApiUserLoginPost200ResponseOneOf
     */
    'infos': ApiUserLoginPost200ResponseOneOfInfos;
}
/**
 * 
 * @export
 * @interface ApiUserLoginPost200ResponseOneOfInfos
 */
export interface ApiUserLoginPost200ResponseOneOfInfos {
    /**
     * 
     * @type {string}
     * @memberof ApiUserLoginPost200ResponseOneOfInfos
     */
    'handle': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserLoginPost200ResponseOneOfInfos
     */
    'avatar': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserLoginPost200ResponseOneOfInfos
     */
    'twoFactorValidate': string;
}
/**
 * 
 * @export
 * @interface ApiUserLoginPostRequest
 */
export interface ApiUserLoginPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserLoginPostRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserLoginPostRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserLoginPostRequest
     */
    'captcha': string;
}
/**
 * 
 * @export
 * @interface ApiUserMeDeleteRequest
 */
export interface ApiUserMeDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserMeDeleteRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserMeDeleteRequest
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface ApiUserMeGet200Response
 */
export interface ApiUserMeGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserMeGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {FullUser}
     * @memberof ApiUserMeGet200Response
     */
    'user': FullUser;
}
/**
 * 
 * @export
 * @interface ApiUserMePatchRequest
 */
export interface ApiUserMePatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserMePatchRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserMePatchRequest
     */
    'biography'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserMePatchRequest
     */
    'handle'?: string;
}
/**
 * 
 * @export
 * @interface ApiUserNodesAutocompleteGet200Response
 */
export interface ApiUserNodesAutocompleteGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserNodesAutocompleteGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Array<ApiUserNodesAutocompleteGet200ResponseNodesInner>}
     * @memberof ApiUserNodesAutocompleteGet200Response
     */
    'nodes': Array<ApiUserNodesAutocompleteGet200ResponseNodesInner>;
}
/**
 * 
 * @export
 * @interface ApiUserNodesAutocompleteGet200ResponseNodesInner
 */
export interface ApiUserNodesAutocompleteGet200ResponseNodesInner {
    /**
     * 
     * @type {number}
     * @memberof ApiUserNodesAutocompleteGet200ResponseNodesInner
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ApiUserNodesAutocompleteGet200ResponseNodesInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiUserNodesGet200Response
 */
export interface ApiUserNodesGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserNodesGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserNodesGet200ResponseList}
     * @memberof ApiUserNodesGet200Response
     */
    'list': ApiUserNodesGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiUserNodesGet200ResponseList
 */
export interface ApiUserNodesGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiUserNodesGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<Node>}
     * @memberof ApiUserNodesGet200ResponseList
     */
    'data': Array<Node>;
}
/**
 * 
 * @export
 * @interface ApiUserNodesNodeAllocationsAllocationPatchRequest
 */
export interface ApiUserNodesNodeAllocationsAllocationPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserNodesNodeAllocationsAllocationPatchRequest
     */
    'ip': string | null;
}
/**
 * 
 * @export
 * @interface ApiUserNodesNodeAllocationsGet200Response
 */
export interface ApiUserNodesNodeAllocationsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserNodesNodeAllocationsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserNodesNodeAllocationsGet200ResponseList}
     * @memberof ApiUserNodesNodeAllocationsGet200Response
     */
    'list': ApiUserNodesNodeAllocationsGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiUserNodesNodeAllocationsGet200ResponseList
 */
export interface ApiUserNodesNodeAllocationsGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiUserNodesNodeAllocationsGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<NodeAllocation>}
     * @memberof ApiUserNodesNodeAllocationsGet200ResponseList
     */
    'data': Array<NodeAllocation>;
}
/**
 * 
 * @export
 * @interface ApiUserNodesNodeAllocationsPost200Response
 */
export interface ApiUserNodesNodeAllocationsPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserNodesNodeAllocationsPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {NodeAllocation}
     * @memberof ApiUserNodesNodeAllocationsPost200Response
     */
    'allocation': NodeAllocation;
}
/**
 * 
 * @export
 * @interface ApiUserNodesNodeAllocationsPostRequest
 */
export interface ApiUserNodesNodeAllocationsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserNodesNodeAllocationsPostRequest
     */
    'ip'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiUserNodesNodeAllocationsPostRequest
     */
    'port': number;
}
/**
 * 
 * @export
 * @interface ApiUserNodesNodePatchRequest
 */
export interface ApiUserNodesNodePatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserNodesNodePatchRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserNodesNodePatchRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserNodesNodePatchRequest
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ApiUserNodesNodeStatsGet200Response
 */
export interface ApiUserNodesNodeStatsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserNodesNodeStatsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserNodesNodeStatsGet200ResponseStats}
     * @memberof ApiUserNodesNodeStatsGet200Response
     */
    'stats': ApiUserNodesNodeStatsGet200ResponseStats;
}
/**
 * 
 * @export
 * @interface ApiUserNodesNodeStatsGet200ResponseStats
 */
export interface ApiUserNodesNodeStatsGet200ResponseStats {
    /**
     * 
     * @type {number}
     * @memberof ApiUserNodesNodeStatsGet200ResponseStats
     */
    'uptime': number;
    /**
     * 
     * @type {ApiUserNodesNodeStatsGet200ResponseStatsCpu}
     * @memberof ApiUserNodesNodeStatsGet200ResponseStats
     */
    'cpu': ApiUserNodesNodeStatsGet200ResponseStatsCpu;
    /**
     * 
     * @type {ApiUserNodesNodeStatsGet200ResponseStatsMemory}
     * @memberof ApiUserNodesNodeStatsGet200ResponseStats
     */
    'memory': ApiUserNodesNodeStatsGet200ResponseStatsMemory;
    /**
     * 
     * @type {ApiUserNodesNodeStatsGet200ResponseStatsMemory}
     * @memberof ApiUserNodesNodeStatsGet200ResponseStats
     */
    'disk': ApiUserNodesNodeStatsGet200ResponseStatsMemory;
}
/**
 * 
 * @export
 * @interface ApiUserNodesNodeStatsGet200ResponseStatsCpu
 */
export interface ApiUserNodesNodeStatsGet200ResponseStatsCpu {
    /**
     * 
     * @type {number}
     * @memberof ApiUserNodesNodeStatsGet200ResponseStatsCpu
     */
    'cores': number;
    /**
     * 
     * @type {string}
     * @memberof ApiUserNodesNodeStatsGet200ResponseStatsCpu
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ApiUserNodesNodeStatsGet200ResponseStatsCpu
     */
    'usage': number;
}
/**
 * 
 * @export
 * @interface ApiUserNodesNodeStatsGet200ResponseStatsMemory
 */
export interface ApiUserNodesNodeStatsGet200ResponseStatsMemory {
    /**
     * 
     * @type {number}
     * @memberof ApiUserNodesNodeStatsGet200ResponseStatsMemory
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserNodesNodeStatsGet200ResponseStatsMemory
     */
    'used': number;
}
/**
 * 
 * @export
 * @interface ApiUserNodesPost200Response
 */
export interface ApiUserNodesPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserNodesPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Node}
     * @memberof ApiUserNodesPost200Response
     */
    'node': Node;
}
/**
 * 
 * @export
 * @interface ApiUserNodesPostRequest
 */
export interface ApiUserNodesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserNodesPostRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserNodesPostRequest
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ApiUserOauthPostRequest
 */
export interface ApiUserOauthPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserOauthPostRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserOauthPostRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserOauthPostRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserOauthPostRequest
     */
    'handle': string;
}
/**
 * 
 * @export
 * @interface ApiUserPasswordPatchRequest
 */
export interface ApiUserPasswordPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserPasswordPatchRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserPasswordPatchRequest
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface ApiUserPasswordResetPatchRequest
 */
export interface ApiUserPasswordResetPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserPasswordResetPatchRequest
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserPasswordResetPatchRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ApiUserPasswordResetPostRequest
 */
export interface ApiUserPasswordResetPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserPasswordResetPostRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserPasswordResetPostRequest
     */
    'captcha': string;
}
/**
 * 
 * @export
 * @interface ApiUserPost200Response
 */
export interface ApiUserPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {FullUser}
     * @memberof ApiUserPost200Response
     */
    'user': FullUser;
    /**
     * 
     * @type {string}
     * @memberof ApiUserPost200Response
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ApiUserPostRequest
 */
export interface ApiUserPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserPostRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserPostRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserPostRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserPostRequest
     */
    'handle': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserPostRequest
     */
    'captcha': string;
}
/**
 * 
 * @export
 * @interface ApiUserServersGet200Response
 */
export interface ApiUserServersGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserServersGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserServersGet200ResponseList}
     * @memberof ApiUserServersGet200Response
     */
    'list': ApiUserServersGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiUserServersGet200ResponseList
 */
export interface ApiUserServersGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiUserServersGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<Server>}
     * @memberof ApiUserServersGet200ResponseList
     */
    'data': Array<Server>;
}
/**
 * 
 * @export
 * @interface ApiUserServersPostRequest
 */
export interface ApiUserServersPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserServersPostRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserServersPostRequest
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof ApiUserServersPostRequest
     */
    'node': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserServersPostRequest
     */
    'template'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserServersPostRequest
     */
    'cpu': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserServersPostRequest
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUserServersPostRequest
     */
    'disk': number;
}
/**
 * 
 * @export
 * @interface ApiUserServersTemplatesAutocompleteGet200Response
 */
export interface ApiUserServersTemplatesAutocompleteGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserServersTemplatesAutocompleteGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Array<ApiUserNodesAutocompleteGet200ResponseNodesInner>}
     * @memberof ApiUserServersTemplatesAutocompleteGet200Response
     */
    'templates': Array<ApiUserNodesAutocompleteGet200ResponseNodesInner>;
}
/**
 * 
 * @export
 * @interface ApiUserServersTemplatesGet200Response
 */
export interface ApiUserServersTemplatesGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserServersTemplatesGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserServersTemplatesGet200ResponseList}
     * @memberof ApiUserServersTemplatesGet200Response
     */
    'list': ApiUserServersTemplatesGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiUserServersTemplatesGet200ResponseList
 */
export interface ApiUserServersTemplatesGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiUserServersTemplatesGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<ServerTemplate>}
     * @memberof ApiUserServersTemplatesGet200ResponseList
     */
    'data': Array<ServerTemplate>;
}
/**
 * 
 * @export
 * @interface ApiUserSessionsGet200Response
 */
export interface ApiUserSessionsGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserSessionsGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserSessionsGet200ResponseList}
     * @memberof ApiUserSessionsGet200Response
     */
    'list': ApiUserSessionsGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiUserSessionsGet200ResponseList
 */
export interface ApiUserSessionsGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiUserSessionsGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<Session>}
     * @memberof ApiUserSessionsGet200ResponseList
     */
    'data': Array<Session>;
}
/**
 * 
 * @export
 * @interface ApiUserSessionsSessionGet200Response
 */
export interface ApiUserSessionsSessionGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserSessionsSessionGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Session}
     * @memberof ApiUserSessionsSessionGet200Response
     */
    'session': Session;
}
/**
 * 
 * @export
 * @interface ApiUserSshKeysGet200Response
 */
export interface ApiUserSshKeysGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserSshKeysGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserSshKeysGet200ResponseList}
     * @memberof ApiUserSshKeysGet200Response
     */
    'list': ApiUserSshKeysGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiUserSshKeysGet200ResponseList
 */
export interface ApiUserSshKeysGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiUserSshKeysGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<SshKey>}
     * @memberof ApiUserSshKeysGet200ResponseList
     */
    'data': Array<SshKey>;
}
/**
 * 
 * @export
 * @interface ApiUserSshKeysPost200Response
 */
export interface ApiUserSshKeysPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserSshKeysPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {SshKey}
     * @memberof ApiUserSshKeysPost200Response
     */
    'key': SshKey;
}
/**
 * 
 * @export
 * @interface ApiUserSshKeysPostRequest
 */
export interface ApiUserSshKeysPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserSshKeysPostRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserSshKeysPostRequest
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface ApiUserTicketsPost200Response
 */
export interface ApiUserTicketsPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserTicketsPost200Response
     */
    'success': boolean;
    /**
     * 
     * @type {Ticket}
     * @memberof ApiUserTicketsPost200Response
     */
    'ticket': Ticket;
}
/**
 * 
 * @export
 * @interface ApiUserTicketsPostRequest
 */
export interface ApiUserTicketsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiUserTicketsPostRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserTicketsPostRequest
     */
    'category': ApiUserTicketsPostRequestCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiUserTicketsPostRequest
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserTicketsPostRequest
     */
    'captcha': string;
}

export const ApiUserTicketsPostRequestCategoryEnum = {
    Billing: 'BILLING',
    Sales: 'SALES',
    Website: 'WEBSITE',
    Privacy: 'PRIVACY',
    Service: 'SERVICE',
    Abuse: 'ABUSE'
} as const;

export type ApiUserTicketsPostRequestCategoryEnum = typeof ApiUserTicketsPostRequestCategoryEnum[keyof typeof ApiUserTicketsPostRequestCategoryEnum];

/**
 * 
 * @export
 * @interface ApiUserTicketsTicketMessagesGet200Response
 */
export interface ApiUserTicketsTicketMessagesGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserTicketsTicketMessagesGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {ApiUserTicketsTicketMessagesGet200ResponseList}
     * @memberof ApiUserTicketsTicketMessagesGet200Response
     */
    'list': ApiUserTicketsTicketMessagesGet200ResponseList;
}
/**
 * 
 * @export
 * @interface ApiUserTicketsTicketMessagesGet200ResponseList
 */
export interface ApiUserTicketsTicketMessagesGet200ResponseList {
    /**
     * 
     * @type {ApiAdminPollsGet200ResponseListMeta}
     * @memberof ApiUserTicketsTicketMessagesGet200ResponseList
     */
    'meta': ApiAdminPollsGet200ResponseListMeta;
    /**
     * 
     * @type {Array<TicketMessage>}
     * @memberof ApiUserTicketsTicketMessagesGet200ResponseList
     */
    'data': Array<TicketMessage>;
}
/**
 * 
 * @export
 * @interface ApiUserUserGet200Response
 */
export interface ApiUserUserGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUserUserGet200Response
     */
    'success': boolean;
    /**
     * 
     * @type {PublicUser}
     * @memberof ApiUserUserGet200Response
     */
    'user': PublicUser;
}
/**
 * 
 * @export
 * @interface Friend
 */
export interface Friend {
    /**
     * 
     * @type {PublicUser}
     * @memberof Friend
     */
    'user': PublicUser;
    /**
     * 
     * @type {string}
     * @memberof Friend
     */
    'since': string;
    /**
     * 
     * @type {boolean}
     * @memberof Friend
     */
    'pending': boolean;
}
/**
 * 
 * @export
 * @interface FullUser
 */
export interface FullUser {
    /**
     * 
     * @type {number}
     * @memberof FullUser
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'biography': string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'handle': string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof FullUser
     */
    'balance': number;
    /**
     * 
     * @type {boolean}
     * @memberof FullUser
     */
    'twoFactorEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'avatar': string;
    /**
     * 
     * @type {boolean}
     * @memberof FullUser
     */
    'friendRequestsEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FullUser
     */
    'developer': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FullUser
     */
    'admin': boolean;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'lastLogin': string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'created'?: string;
    /**
     * 
     * @type {number}
     * @memberof FullUser
     */
    'nodeSlots': number;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'expires': string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'status': InvoiceStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'type': InvoiceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'created': string;
}

export const InvoiceStatusEnum = {
    Pending: 'PENDING',
    Paid: 'PAID',
    Cancelled: 'CANCELLED'
} as const;

export type InvoiceStatusEnum = typeof InvoiceStatusEnum[keyof typeof InvoiceStatusEnum];
export const InvoiceTypeEnum = {
    PayServer: 'PAY_SERVER',
    PayUser: 'PAY_USER',
    AddBalance: 'ADD_BALANCE',
    AddDonation: 'ADD_DONATION'
} as const;

export type InvoiceTypeEnum = typeof InvoiceTypeEnum[keyof typeof InvoiceTypeEnum];

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {boolean}
     * @memberof ModelError
     */
    'success'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModelError
     */
    'errors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * 
     * @type {number}
     * @memberof Node
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof Node
     */
    'url': string;
    /**
     * 
     * @type {NodeCount}
     * @memberof Node
     */
    '_count': NodeCount;
}
/**
 * 
 * @export
 * @interface NodeAllocation
 */
export interface NodeAllocation {
    /**
     * 
     * @type {number}
     * @memberof NodeAllocation
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NodeAllocation
     */
    'ip': string | null;
    /**
     * 
     * @type {number}
     * @memberof NodeAllocation
     */
    'port': number;
    /**
     * 
     * @type {string}
     * @memberof NodeAllocation
     */
    'created': string;
    /**
     * 
     * @type {NodeAllocationAllocation}
     * @memberof NodeAllocation
     */
    'allocation': NodeAllocationAllocation | null;
}
/**
 * 
 * @export
 * @interface NodeAllocationAllocation
 */
export interface NodeAllocationAllocation {
    /**
     * 
     * @type {number}
     * @memberof NodeAllocationAllocation
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof NodeAllocationAllocation
     */
    'port': number;
    /**
     * 
     * @type {string}
     * @memberof NodeAllocationAllocation
     */
    'created': string;
    /**
     * 
     * @type {NodeAllocationAllocationServer}
     * @memberof NodeAllocationAllocation
     */
    'server': NodeAllocationAllocationServer;
}
/**
 * 
 * @export
 * @interface NodeAllocationAllocationServer
 */
export interface NodeAllocationAllocationServer {
    /**
     * 
     * @type {number}
     * @memberof NodeAllocationAllocationServer
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NodeAllocationAllocationServer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NodeAllocationAllocationServer
     */
    'icon': string;
}
/**
 * 
 * @export
 * @interface NodeCount
 */
export interface NodeCount {
    /**
     * 
     * @type {number}
     * @memberof NodeCount
     */
    'servers': number;
}
/**
 * 
 * @export
 * @interface Permissions
 */
export interface Permissions {
    /**
     * 
     * @type {Array<PermissionsListInner>}
     * @memberof Permissions
     */
    'list': Array<PermissionsListInner>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof Permissions
     */
    'enum': { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface PermissionsListInner
 */
export interface PermissionsListInner {
    /**
     * 
     * @type {string}
     * @memberof PermissionsListInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionsListInner
     */
    'description': string;
    /**
     * The bitwise permission value
     * @type {number}
     * @memberof PermissionsListInner
     */
    'value': number;
    /**
     * 
     * @type {Array<PermissionsListInnerRoutesInner>}
     * @memberof PermissionsListInner
     */
    'routes': Array<PermissionsListInnerRoutesInner>;
}
/**
 * 
 * @export
 * @interface PermissionsListInnerRoutesInner
 */
export interface PermissionsListInnerRoutesInner {
    /**
     * 
     * @type {string}
     * @memberof PermissionsListInnerRoutesInner
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionsListInnerRoutesInner
     */
    'method': PermissionsListInnerRoutesInnerMethodEnum;
}

export const PermissionsListInnerRoutesInnerMethodEnum = {
    Connect: 'CONNECT',
    Trace: 'TRACE',
    Options: 'OPTIONS',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD',
    Post: 'POST',
    Put: 'PUT',
    Get: 'GET'
} as const;

export type PermissionsListInnerRoutesInnerMethodEnum = typeof PermissionsListInnerRoutesInnerMethodEnum[keyof typeof PermissionsListInnerRoutesInnerMethodEnum];

/**
 * 
 * @export
 * @interface Poll
 */
export interface Poll {
    /**
     * 
     * @type {number}
     * @memberof Poll
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Poll
     */
    'title': string;
    /**
     * 
     * @type {boolean}
     * @memberof Poll
     */
    'open': boolean;
    /**
     * 
     * @type {string}
     * @memberof Poll
     */
    'created': string;
    /**
     * 
     * @type {boolean}
     * @memberof Poll
     */
    'multiSelect': boolean;
    /**
     * 
     * @type {Array<PollOptionsInner>}
     * @memberof Poll
     */
    'options': Array<PollOptionsInner>;
}
/**
 * 
 * @export
 * @interface PollOptionsInner
 */
export interface PollOptionsInner {
    /**
     * 
     * @type {number}
     * @memberof PollOptionsInner
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PollOptionsInner
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof PollOptionsInner
     */
    'answers': number;
    /**
     * 
     * @type {boolean}
     * @memberof PollOptionsInner
     */
    'voted': boolean;
}
/**
 * 
 * @export
 * @interface PublicUser
 */
export interface PublicUser {
    /**
     * 
     * @type {number}
     * @memberof PublicUser
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'handle': string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'biography': string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'created': string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicUser
     */
    'developer': boolean;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'avatar': string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicUser
     */
    'friendRequestsEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PublicUser
     */
    'admin': boolean;
}
/**
 * 
 * @export
 * @interface Server
 */
export interface Server {
    /**
     * 
     * @type {number}
     * @memberof Server
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Server
     */
    'state': ServerStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Server
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Server
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Server
     */
    'icon': string;
    /**
     * 
     * @type {boolean}
     * @memberof Server
     */
    'pendingRestart': boolean;
    /**
     * 
     * @type {string}
     * @memberof Server
     */
    'created': string;
    /**
     * 
     * @type {ServerNode}
     * @memberof Server
     */
    'node': ServerNode;
    /**
     * 
     * @type {PublicUser}
     * @memberof Server
     */
    'owner': PublicUser;
    /**
     * 
     * @type {number}
     * @memberof Server
     */
    'cpu': number;
    /**
     * 
     * @type {number}
     * @memberof Server
     */
    'memory': number;
    /**
     * 
     * @type {number}
     * @memberof Server
     */
    'disk': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Server
     */
    'permissions': Array<number>;
}

export const ServerStateEnum = {
    Neutral: 'NEUTRAL',
    Configuring: 'CONFIGURING',
    Installing: 'INSTALLING',
    BackingUp: 'BACKING_UP',
    Restoring: 'RESTORING'
} as const;

export type ServerStateEnum = typeof ServerStateEnum[keyof typeof ServerStateEnum];

/**
 * 
 * @export
 * @interface ServerAction
 */
export interface ServerAction {
    /**
     * 
     * @type {number}
     * @memberof ServerAction
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServerAction
     */
    'event': string;
    /**
     * 
     * @type {object}
     * @memberof ServerAction
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof ServerAction
     */
    'logged': string;
    /**
     * 
     * @type {string}
     * @memberof ServerAction
     */
    'ipAddress': string;
    /**
     * 
     * @type {string}
     * @memberof ServerAction
     */
    'userAgent': string;
    /**
     * 
     * @type {PublicUser}
     * @memberof ServerAction
     */
    'user': PublicUser;
}
/**
 * 
 * @export
 * @interface ServerAllocation
 */
export interface ServerAllocation {
    /**
     * 
     * @type {number}
     * @memberof ServerAllocation
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof ServerAllocation
     */
    'port': number;
    /**
     * 
     * @type {string}
     * @memberof ServerAllocation
     */
    'created': string;
    /**
     * 
     * @type {ServerAllocationAllocation}
     * @memberof ServerAllocation
     */
    'allocation': ServerAllocationAllocation;
}
/**
 * 
 * @export
 * @interface ServerAllocationAllocation
 */
export interface ServerAllocationAllocation {
    /**
     * 
     * @type {number}
     * @memberof ServerAllocationAllocation
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServerAllocationAllocation
     */
    'ip': string | null;
    /**
     * 
     * @type {number}
     * @memberof ServerAllocationAllocation
     */
    'port': number;
}
/**
 * 
 * @export
 * @interface ServerFileArchive
 */
export interface ServerFileArchive {
    /**
     * 
     * @type {number}
     * @memberof ServerFileArchive
     */
    'id': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerFileArchive
     */
    'paths': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ServerFileArchive
     */
    'path': string;
    /**
     * 
     * @type {number}
     * @memberof ServerFileArchive
     */
    'progress': number;
    /**
     * 
     * @type {string}
     * @memberof ServerFileArchive
     */
    'type'?: ServerFileArchiveTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ServerFileArchive
     */
    'mode'?: ServerFileArchiveModeEnum;
    /**
     * 
     * @type {number}
     * @memberof ServerFileArchive
     */
    'size': number | null;
    /**
     * 
     * @type {string}
     * @memberof ServerFileArchive
     */
    'created': string;
    /**
     * 
     * @type {PublicUser}
     * @memberof ServerFileArchive
     */
    'user': PublicUser;
}

export const ServerFileArchiveTypeEnum = {
    Zip: 'ZIP',
    Tar: 'TAR'
} as const;

export type ServerFileArchiveTypeEnum = typeof ServerFileArchiveTypeEnum[keyof typeof ServerFileArchiveTypeEnum];
export const ServerFileArchiveModeEnum = {
    Compress: 'COMPRESS',
    Decompress: 'DECOMPRESS'
} as const;

export type ServerFileArchiveModeEnum = typeof ServerFileArchiveModeEnum[keyof typeof ServerFileArchiveModeEnum];

/**
 * 
 * @export
 * @interface ServerFilePull
 */
export interface ServerFilePull {
    /**
     * 
     * @type {number}
     * @memberof ServerFilePull
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServerFilePull
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ServerFilePull
     */
    'path': string;
    /**
     * 
     * @type {number}
     * @memberof ServerFilePull
     */
    'progress': number;
    /**
     * 
     * @type {number}
     * @memberof ServerFilePull
     */
    'size': number | null;
    /**
     * 
     * @type {string}
     * @memberof ServerFilePull
     */
    'created': string;
    /**
     * 
     * @type {PublicUser}
     * @memberof ServerFilePull
     */
    'user': PublicUser;
}
/**
 * 
 * @export
 * @interface ServerNode
 */
export interface ServerNode {
    /**
     * 
     * @type {number}
     * @memberof ServerNode
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServerNode
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ServerTemplate
 */
export interface ServerTemplate {
    /**
     * 
     * @type {number}
     * @memberof ServerTemplate
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ServerTemplate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ServerTemplate
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ServerTemplate
     */
    'url': string;
    /**
     * 
     * @type {ApiUserNodesAutocompleteGet200ResponseNodesInner}
     * @memberof ServerTemplate
     */
    'image': ApiUserNodesAutocompleteGet200ResponseNodesInner;
    /**
     * 
     * @type {PublicUser}
     * @memberof ServerTemplate
     */
    'user': PublicUser;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'ipAddress': string;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'requests': number;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'used': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'userAgent': string;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'using': boolean;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'expires': string;
}
/**
 * 
 * @export
 * @interface SshKey
 */
export interface SshKey {
    /**
     * 
     * @type {number}
     * @memberof SshKey
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SshKey
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SshKey
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof SshKey
     */
    'created': string;
}
/**
 * 
 * @export
 * @interface SubUser
 */
export interface SubUser {
    /**
     * 
     * @type {number}
     * @memberof SubUser
     */
    'id': number;
    /**
     * 
     * @type {PublicUser}
     * @memberof SubUser
     */
    'user': PublicUser;
    /**
     * 
     * @type {Array<number>}
     * @memberof SubUser
     */
    'permissions': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof SubUser
     */
    'used': string | null;
    /**
     * 
     * @type {string}
     * @memberof SubUser
     */
    'created': string;
}
/**
 * 
 * @export
 * @interface Ticket
 */
export interface Ticket {
    /**
     * 
     * @type {number}
     * @memberof Ticket
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'title': string;
    /**
     * 
     * @type {boolean}
     * @memberof Ticket
     */
    'open': boolean;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'category': TicketCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    'lastResponse': string | null;
}

export const TicketCategoryEnum = {
    Billing: 'BILLING',
    Sales: 'SALES',
    Website: 'WEBSITE',
    Privacy: 'PRIVACY',
    Service: 'SERVICE',
    Abuse: 'ABUSE'
} as const;

export type TicketCategoryEnum = typeof TicketCategoryEnum[keyof typeof TicketCategoryEnum];

/**
 * 
 * @export
 * @interface TicketMessage
 */
export interface TicketMessage {
    /**
     * 
     * @type {number}
     * @memberof TicketMessage
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TicketMessage
     */
    'content': string;
    /**
     * 
     * @type {PublicUser}
     * @memberof TicketMessage
     */
    'user': PublicUser | null;
    /**
     * 
     * @type {string}
     * @memberof TicketMessage
     */
    'sent': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Admin Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Polls
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminPollsGet: async (page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/polls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Poll
         * @param {number} poll The ID of the poll
         * @param {ApiAdminPollsPollPatchRequest} [apiAdminPollsPollPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminPollsPollPatch: async (poll: number, apiAdminPollsPollPatchRequest?: ApiAdminPollsPollPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poll' is not null or undefined
            assertParamExists('apiAdminPollsPollPatch', 'poll', poll)
            const localVarPath = `/api/admin/polls/{poll}`
                .replace(`{${"poll"}}`, encodeURIComponent(String(poll)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiAdminPollsPollPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Poll
         * @param {ApiAdminPollsPostRequest} [apiAdminPollsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminPollsPost: async (apiAdminPollsPostRequest?: ApiAdminPollsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/polls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiAdminPollsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Tickets
         * @param {ApiAdminTicketsGetTypeEnum} type The type of tickets to get
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminTicketsGet: async (type: ApiAdminTicketsGetTypeEnum, page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('apiAdminTicketsGet', 'type', type)
            const localVarPath = `/api/admin/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksOauthDiscordGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/hooks/oauth/discord`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksOauthGithubGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/hooks/oauth/github`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksOauthGoogleGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/hooks/oauth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksPaypalCancelGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/hooks/paypal/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksPaypalReturnGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/hooks/paypal/return`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Global Infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInfosGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/infos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Node Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNodeInfosGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/node/infos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server Allocations
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNodeServerServerAllocationsGet: async (server: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiNodeServerServerAllocationsGet', 'server', server)
            const localVarPath = `/api/node/server/{server}/allocations`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Archive Status
         * @param {number} server The ID of the server
         * @param {ApiNodeServerServerFilesPullPostRequest} [apiNodeServerServerFilesPullPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNodeServerServerFilesArchivePost: async (server: number, apiNodeServerServerFilesPullPostRequest?: ApiNodeServerServerFilesPullPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiNodeServerServerFilesArchivePost', 'server', server)
            const localVarPath = `/api/node/server/{server}/files/archive`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiNodeServerServerFilesPullPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Pull Status
         * @param {number} server The ID of the server
         * @param {ApiNodeServerServerFilesPullPostRequest} [apiNodeServerServerFilesPullPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNodeServerServerFilesPullPost: async (server: number, apiNodeServerServerFilesPullPostRequest?: ApiNodeServerServerFilesPullPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiNodeServerServerFilesPullPost', 'server', server)
            const localVarPath = `/api/node/server/{server}/files/pull`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiNodeServerServerFilesPullPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate Server SSH Credentials
         * @param {number} server The ID of the server
         * @param {ApiNodeServerServerSshPostRequest} [apiNodeServerServerSshPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNodeServerServerSshPost: async (server: number, apiNodeServerServerSshPostRequest?: ApiNodeServerServerSshPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiNodeServerServerSshPost', 'server', server)
            const localVarPath = `/api/node/server/{server}/ssh`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiNodeServerServerSshPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Server State
         * @param {number} server The ID of the server
         * @param {ApiNodeServerServerStatePostRequest} [apiNodeServerServerStatePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNodeServerServerStatePost: async (server: number, apiNodeServerServerStatePostRequest?: ApiNodeServerServerStatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiNodeServerServerStatePost', 'server', server)
            const localVarPath = `/api/node/server/{server}/state`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiNodeServerServerStatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OpenAPI Docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOpenapiGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/openapi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all available permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Polls
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPollsGet: async (page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/polls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Poll
         * @param {number} poll The Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPollsPollGet: async (poll: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poll' is not null or undefined
            assertParamExists('apiPollsPollGet', 'poll', poll)
            const localVarPath = `/api/polls/{poll}`
                .replace(`{${"poll"}}`, encodeURIComponent(String(poll)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server Actions
         * @param {number} server The ID of the server
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerActionLogsGet: async (server: number, page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerActionLogsGet', 'server', server)
            const localVarPath = `/api/server/{server}/action-logs`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Server Allocation
         * @param {number} server The ID of the server
         * @param {number} allocation The ID of the allocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerAllocationsAllocationDelete: async (server: number, allocation: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerAllocationsAllocationDelete', 'server', server)
            // verify required parameter 'allocation' is not null or undefined
            assertParamExists('apiServerServerAllocationsAllocationDelete', 'allocation', allocation)
            const localVarPath = `/api/server/{server}/allocations/{allocation}`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)))
                .replace(`{${"allocation"}}`, encodeURIComponent(String(allocation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Server Allocation
         * @param {number} server The ID of the server
         * @param {number} allocation The ID of the allocation
         * @param {ApiServerServerAllocationsAllocationPatchRequest} [apiServerServerAllocationsAllocationPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerAllocationsAllocationPatch: async (server: number, allocation: number, apiServerServerAllocationsAllocationPatchRequest?: ApiServerServerAllocationsAllocationPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerAllocationsAllocationPatch', 'server', server)
            // verify required parameter 'allocation' is not null or undefined
            assertParamExists('apiServerServerAllocationsAllocationPatch', 'allocation', allocation)
            const localVarPath = `/api/server/{server}/allocations/{allocation}`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)))
                .replace(`{${"allocation"}}`, encodeURIComponent(String(allocation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerAllocationsAllocationPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server Node Allocations Autocomplete
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerAllocationsAutocompleteGet: async (server: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerAllocationsAutocompleteGet', 'server', server)
            const localVarPath = `/api/server/{server}/allocations/autocomplete`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Server Allocations
         * @param {number} server The ID of the server
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerAllocationsDelete: async (server: number, apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerAllocationsDelete', 'server', server)
            const localVarPath = `/api/server/{server}/allocations`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerSubusersDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server Allocations
         * @param {number} server The ID of the server
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerAllocationsGet: async (server: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerAllocationsGet', 'server', server)
            const localVarPath = `/api/server/{server}/allocations`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Server Allocation
         * @param {number} server The ID of the server
         * @param {ApiServerServerAllocationsPostRequest} [apiServerServerAllocationsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerAllocationsPost: async (server: number, apiServerServerAllocationsPostRequest?: ApiServerServerAllocationsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerAllocationsPost', 'server', server)
            const localVarPath = `/api/server/{server}/allocations`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerAllocationsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Server
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerDelete: async (server: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerDelete', 'server', server)
            const localVarPath = `/api/server/{server}`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Abort Server File Archive Operation
         * @param {number} server The ID of the server
         * @param {number} archive The ID of the archive operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesArchivesArchiveDelete: async (server: number, archive: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerFilesArchivesArchiveDelete', 'server', server)
            // verify required parameter 'archive' is not null or undefined
            assertParamExists('apiServerServerFilesArchivesArchiveDelete', 'archive', archive)
            const localVarPath = `/api/server/{server}/files/archives/{archive}`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)))
                .replace(`{${"archive"}}`, encodeURIComponent(String(archive)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server Archive Operations
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesArchivesGet: async (server: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerFilesArchivesGet', 'server', server)
            const localVarPath = `/api/server/{server}/files/archives`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archive Server Files
         * @param {number} server The ID of the server
         * @param {string} path The path to the file or directory
         * @param {ApiServerServerFilesArchivesPostRequest} [apiServerServerFilesArchivesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesArchivesPost: async (server: number, path: string, apiServerServerFilesArchivesPostRequest?: ApiServerServerFilesArchivesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerFilesArchivesPost', 'server', server)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('apiServerServerFilesArchivesPost', 'path', path)
            const localVarPath = `/api/server/{server}/files/archives`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerFilesArchivesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Server Files
         * @param {number} server The ID of the server
         * @param {ApiServerServerFilesDeletePostRequest} [apiServerServerFilesDeletePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesDeletePost: async (server: number, apiServerServerFilesDeletePostRequest?: ApiServerServerFilesDeletePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerFilesDeletePost', 'server', server)
            const localVarPath = `/api/server/{server}/files/delete`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerFilesDeletePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server Files
         * @param {number} server The ID of the server
         * @param {string} path The path to the file or directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesGet: async (server: number, path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerFilesGet', 'server', server)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('apiServerServerFilesGet', 'path', path)
            const localVarPath = `/api/server/{server}/files`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server File Hashes
         * @param {number} server The ID of the server
         * @param {string} path The path to the file or directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesHashGet: async (server: number, path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerFilesHashGet', 'server', server)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('apiServerServerFilesHashGet', 'path', path)
            const localVarPath = `/api/server/{server}/files/hash`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server File Pulls
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesPullsGet: async (server: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerFilesPullsGet', 'server', server)
            const localVarPath = `/api/server/{server}/files/pulls`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pull Server File
         * @param {number} server The ID of the server
         * @param {string} path The path to the file or directory
         * @param {ApiServerServerFilesPullsPostRequest} [apiServerServerFilesPullsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesPullsPost: async (server: number, path: string, apiServerServerFilesPullsPostRequest?: ApiServerServerFilesPullsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerFilesPullsPost', 'server', server)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('apiServerServerFilesPullsPost', 'path', path)
            const localVarPath = `/api/server/{server}/files/pulls`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerFilesPullsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Abort Server File Pull
         * @param {number} server The ID of the server
         * @param {number} pull The ID of the pull
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesPullsPullDelete: async (server: number, pull: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerFilesPullsPullDelete', 'server', server)
            // verify required parameter 'pull' is not null or undefined
            assertParamExists('apiServerServerFilesPullsPullDelete', 'pull', pull)
            const localVarPath = `/api/server/{server}/files/pulls/{pull}`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)))
                .replace(`{${"pull"}}`, encodeURIComponent(String(pull)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerGet: async (server: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerGet', 'server', server)
            const localVarPath = `/api/server/{server}`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Server Icon
         * @param {number} server The ID of the server
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerIconPost: async (server: number, body?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerIconPost', 'server', server)
            const localVarPath = `/api/server/{server}/icon`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'image/png';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Server
         * @param {number} server The ID of the server
         * @param {ApiServerServerPatchRequest} [apiServerServerPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerPatch: async (server: number, apiServerServerPatchRequest?: ApiServerServerPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerPatch', 'server', server)
            const localVarPath = `/api/server/{server}`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Server Disk
         * @param {number} server The ID of the server
         * @param {ApiServerServerResourcesDiskPatchRequest} [apiServerServerResourcesDiskPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerResourcesDiskPatch: async (server: number, apiServerServerResourcesDiskPatchRequest?: ApiServerServerResourcesDiskPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerResourcesDiskPatch', 'server', server)
            const localVarPath = `/api/server/{server}/resources/disk`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerResourcesDiskPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Server Resources
         * @param {number} server The ID of the server
         * @param {ApiServerServerResourcesPatchRequest} [apiServerServerResourcesPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerResourcesPatch: async (server: number, apiServerServerResourcesPatchRequest?: ApiServerServerResourcesPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerResourcesPatch', 'server', server)
            const localVarPath = `/api/server/{server}/resources`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerResourcesPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server SSH Info
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerSshGet: async (server: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerSshGet', 'server', server)
            const localVarPath = `/api/server/{server}/ssh`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server Stats
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerStatsGet: async (server: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerStatsGet', 'server', server)
            const localVarPath = `/api/server/{server}/stats`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Server Status
         * @param {number} server The ID of the server
         * @param {ApiServerServerStatusPostRequest} [apiServerServerStatusPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerStatusPost: async (server: number, apiServerServerStatusPostRequest?: ApiServerServerStatusPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerStatusPost', 'server', server)
            const localVarPath = `/api/server/{server}/status`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerStatusPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Subusers
         * @param {number} server The ID of the server
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerSubusersDelete: async (server: number, apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerSubusersDelete', 'server', server)
            const localVarPath = `/api/server/{server}/subusers`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerSubusersDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Subusers
         * @param {number} server The ID of the server
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerSubusersGet: async (server: number, page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerSubusersGet', 'server', server)
            const localVarPath = `/api/server/{server}/subusers`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Subuser
         * @param {number} server The ID of the server
         * @param {ApiServerServerSubusersPostRequest} [apiServerServerSubusersPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerSubusersPost: async (server: number, apiServerServerSubusersPostRequest?: ApiServerServerSubusersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerSubusersPost', 'server', server)
            const localVarPath = `/api/server/{server}/subusers`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerSubusersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Subuser
         * @param {number} server The ID of the server
         * @param {number} subuser The ID of the subuser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerSubusersSubuserDelete: async (server: number, subuser: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerSubusersSubuserDelete', 'server', server)
            // verify required parameter 'subuser' is not null or undefined
            assertParamExists('apiServerServerSubusersSubuserDelete', 'subuser', subuser)
            const localVarPath = `/api/server/{server}/subusers/{subuser}`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)))
                .replace(`{${"subuser"}}`, encodeURIComponent(String(subuser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Subuser
         * @param {number} server The ID of the server
         * @param {number} subuser The ID of the subuser
         * @param {ApiServerServerSubusersSubuserPatchRequest} [apiServerServerSubusersSubuserPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerSubusersSubuserPatch: async (server: number, subuser: number, apiServerServerSubusersSubuserPatchRequest?: ApiServerServerSubusersSubuserPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'server' is not null or undefined
            assertParamExists('apiServerServerSubusersSubuserPatch', 'server', server)
            // verify required parameter 'subuser' is not null or undefined
            assertParamExists('apiServerServerSubusersSubuserPatch', 'subuser', subuser)
            const localVarPath = `/api/server/{server}/subusers/{subuser}`
                .replace(`{${"server"}}`, encodeURIComponent(String(server)))
                .replace(`{${"subuser"}}`, encodeURIComponent(String(subuser)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerSubusersSubuserPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable 2FA on the account
         * @param {ApiUser2faDeleteRequest} [apiUser2faDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUser2faDelete: async (apiUser2faDeleteRequest?: ApiUser2faDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/2fa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUser2faDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUser2faGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/2fa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable 2FA
         * @param {ApiUser2faPostRequest} [apiUser2faPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUser2faPost: async (apiUser2faPostRequest?: ApiUser2faPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/2fa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUser2faPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Account Actions
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserActionLogsGet: async (page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/action-logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete API Key
         * @param {number} apiKey The ID of the api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApiKeysApiKeyDelete: async (apiKey: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('apiUserApiKeysApiKeyDelete', 'apiKey', apiKey)
            const localVarPath = `/api/user/api-keys/{apiKey}`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update API Key
         * @param {number} apiKey The ID of the api key
         * @param {ApiUserApiKeysApiKeyPatchRequest} [apiUserApiKeysApiKeyPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApiKeysApiKeyPatch: async (apiKey: number, apiUserApiKeysApiKeyPatchRequest?: ApiUserApiKeysApiKeyPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('apiUserApiKeysApiKeyPatch', 'apiKey', apiKey)
            const localVarPath = `/api/user/api-keys/{apiKey}`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserApiKeysApiKeyPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset API Key
         * @param {number} apiKey The ID of the api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApiKeysApiKeyResetKeyPost: async (apiKey: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('apiUserApiKeysApiKeyResetKeyPost', 'apiKey', apiKey)
            const localVarPath = `/api/user/api-keys/{apiKey}/reset-key`
                .replace(`{${"apiKey"}}`, encodeURIComponent(String(apiKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete API Keys
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApiKeysDelete: async (apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerSubusersDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get API Keys
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApiKeysGet: async (page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create API Key
         * @param {ApiUserApiKeysPostRequest} [apiUserApiKeysPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApiKeysPost: async (apiUserApiKeysPostRequest?: ApiUserApiKeysPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserApiKeysPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update User Avatar
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserAvatarPost: async (body?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'image/png';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove Connection
         * @param {ApiUserConnectionsAppDeleteAppEnum} app The app to remove the connection from
         * @param {ApiUserConnectionsAppDeleteRequest} [apiUserConnectionsAppDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserConnectionsAppDelete: async (app: ApiUserConnectionsAppDeleteAppEnum, apiUserConnectionsAppDeleteRequest?: ApiUserConnectionsAppDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            assertParamExists('apiUserConnectionsAppDelete', 'app', app)
            const localVarPath = `/api/user/connections/{app}`
                .replace(`{${"app"}}`, encodeURIComponent(String(app)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserConnectionsAppDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Connection Infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserConnectionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the User Email
         * @param {ApiUserEmailPatchRequest} [apiUserEmailPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserEmailPatch: async (apiUserEmailPatchRequest?: ApiUserEmailPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserEmailPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify the User Email
         * @param {ApiUserEmailVerifyPostRequest} [apiUserEmailVerifyPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserEmailVerifyPost: async (apiUserEmailVerifyPostRequest?: ApiUserEmailVerifyPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/email/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserEmailVerifyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accept Friend Requests
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsAcceptPost: async (apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/friends/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerSubusersDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove Friends
         * @param {ApiUserFriendsDeleteRequest} [apiUserFriendsDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsDelete: async (apiUserFriendsDeleteRequest?: ApiUserFriendsDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserFriendsDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Friends
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsGet: async (page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable Incoming Friend Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsIncomingDisablePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/friends/incoming/disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable Incoming Friend Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsIncomingEnablePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/friends/incoming/enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Pending Friends
         * @param {ApiUserFriendsPendingGetTypeEnum} type The type of pending friends to get
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsPendingGet: async (type: ApiUserFriendsPendingGetTypeEnum, page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('apiUserFriendsPendingGet', 'type', type)
            const localVarPath = `/api/user/friends/pending`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accept Friend Request
         * @param {number} user The ID of the friend request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsUserAcceptPost: async (user: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('apiUserFriendsUserAcceptPost', 'user', user)
            const localVarPath = `/api/user/friends/{user}/accept`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove Friend
         * @param {number} user The ID of the friend request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsUserDelete: async (user: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('apiUserFriendsUserDelete', 'user', user)
            const localVarPath = `/api/user/friends/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Invoices
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserInvoicesCancelPost: async (apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/invoices/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerSubusersDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Invoices
         * @param {number} [page] 
         * @param {ApiUserInvoicesGetTypeEnum} [type] The type of invoices to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserInvoicesGet: async (page?: number, type?: ApiUserInvoicesGetTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Invoice
         * @param {number} invoice The ID of the invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserInvoicesInvoiceCancelPost: async (invoice: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoice' is not null or undefined
            assertParamExists('apiUserInvoicesInvoiceCancelPost', 'invoice', invoice)
            const localVarPath = `/api/user/invoices/{invoice}/cancel`
                .replace(`{${"invoice"}}`, encodeURIComponent(String(invoice)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pay Invoice
         * @param {number} invoice The ID of the invoice
         * @param {ApiUserInvoicesInvoicePayPostRequest} [apiUserInvoicesInvoicePayPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserInvoicesInvoicePayPost: async (invoice: number, apiUserInvoicesInvoicePayPostRequest?: ApiUserInvoicesInvoicePayPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoice' is not null or undefined
            assertParamExists('apiUserInvoicesInvoicePayPost', 'invoice', invoice)
            const localVarPath = `/api/user/invoices/{invoice}/pay`
                .replace(`{${"invoice"}}`, encodeURIComponent(String(invoice)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserInvoicesInvoicePayPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Invoice
         * @param {ApiUserInvoicesPostRequest} [apiUserInvoicesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserInvoicesPost: async (apiUserInvoicesPostRequest?: ApiUserInvoicesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserInvoicesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Invoice Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserInvoicesStatsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/invoices/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login with Two Factor
         * @param {ApiUserLogin2faPostRequest} [apiUserLogin2faPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserLogin2faPost: async (apiUserLogin2faPostRequest?: ApiUserLogin2faPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/login/2fa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserLogin2faPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth2 Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserLoginOauthPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/login/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login
         * @param {ApiUserLoginPostRequest} [apiUserLoginPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserLoginPost: async (apiUserLoginPostRequest?: ApiUserLoginPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserLogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete User
         * @param {ApiUserMeDeleteRequest} [apiUserMeDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserMeDelete: async (apiUserMeDeleteRequest?: ApiUserMeDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserMeDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update User
         * @param {ApiUserMePatchRequest} [apiUserMePatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserMePatch: async (apiUserMePatchRequest?: ApiUserMePatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserMePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Nodes Autocomplete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesAutocompleteGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/nodes/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Nodes
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesGet: async (page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Node Allocation
         * @param {number} node The ID of the node
         * @param {number} allocation The ID of the allocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeAllocationsAllocationDelete: async (node: number, allocation: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'node' is not null or undefined
            assertParamExists('apiUserNodesNodeAllocationsAllocationDelete', 'node', node)
            // verify required parameter 'allocation' is not null or undefined
            assertParamExists('apiUserNodesNodeAllocationsAllocationDelete', 'allocation', allocation)
            const localVarPath = `/api/user/nodes/{node}/allocations/{allocation}`
                .replace(`{${"node"}}`, encodeURIComponent(String(node)))
                .replace(`{${"allocation"}}`, encodeURIComponent(String(allocation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Node Allocation
         * @param {number} node The ID of the node
         * @param {number} allocation The ID of the allocation
         * @param {ApiUserNodesNodeAllocationsAllocationPatchRequest} [apiUserNodesNodeAllocationsAllocationPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeAllocationsAllocationPatch: async (node: number, allocation: number, apiUserNodesNodeAllocationsAllocationPatchRequest?: ApiUserNodesNodeAllocationsAllocationPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'node' is not null or undefined
            assertParamExists('apiUserNodesNodeAllocationsAllocationPatch', 'node', node)
            // verify required parameter 'allocation' is not null or undefined
            assertParamExists('apiUserNodesNodeAllocationsAllocationPatch', 'allocation', allocation)
            const localVarPath = `/api/user/nodes/{node}/allocations/{allocation}`
                .replace(`{${"node"}}`, encodeURIComponent(String(node)))
                .replace(`{${"allocation"}}`, encodeURIComponent(String(allocation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserNodesNodeAllocationsAllocationPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Node Allocations
         * @param {number} node The ID of the node
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeAllocationsDelete: async (node: number, apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'node' is not null or undefined
            assertParamExists('apiUserNodesNodeAllocationsDelete', 'node', node)
            const localVarPath = `/api/user/nodes/{node}/allocations`
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerSubusersDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Node Allocations
         * @param {number} node The ID of the node
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeAllocationsGet: async (node: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'node' is not null or undefined
            assertParamExists('apiUserNodesNodeAllocationsGet', 'node', node)
            const localVarPath = `/api/user/nodes/{node}/allocations`
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Node Allocation
         * @param {number} node The ID of the node
         * @param {ApiUserNodesNodeAllocationsPostRequest} [apiUserNodesNodeAllocationsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeAllocationsPost: async (node: number, apiUserNodesNodeAllocationsPostRequest?: ApiUserNodesNodeAllocationsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'node' is not null or undefined
            assertParamExists('apiUserNodesNodeAllocationsPost', 'node', node)
            const localVarPath = `/api/user/nodes/{node}/allocations`
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserNodesNodeAllocationsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Node
         * @param {number} node The ID of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeDelete: async (node: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'node' is not null or undefined
            assertParamExists('apiUserNodesNodeDelete', 'node', node)
            const localVarPath = `/api/user/nodes/{node}`
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Node
         * @param {number} node The ID of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeGet: async (node: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'node' is not null or undefined
            assertParamExists('apiUserNodesNodeGet', 'node', node)
            const localVarPath = `/api/user/nodes/{node}`
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Node
         * @param {number} node The ID of the node
         * @param {ApiUserNodesNodePatchRequest} [apiUserNodesNodePatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodePatch: async (node: number, apiUserNodesNodePatchRequest?: ApiUserNodesNodePatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'node' is not null or undefined
            assertParamExists('apiUserNodesNodePatch', 'node', node)
            const localVarPath = `/api/user/nodes/{node}`
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserNodesNodePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset Node Key
         * @param {number} node The ID of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeResetKeyPost: async (node: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'node' is not null or undefined
            assertParamExists('apiUserNodesNodeResetKeyPost', 'node', node)
            const localVarPath = `/api/user/nodes/{node}/reset-key`
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Node Stats
         * @param {number} node The ID of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeStatsGet: async (node: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'node' is not null or undefined
            assertParamExists('apiUserNodesNodeStatsGet', 'node', node)
            const localVarPath = `/api/user/nodes/{node}/stats`
                .replace(`{${"node"}}`, encodeURIComponent(String(node)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Node
         * @param {ApiUserNodesPostRequest} [apiUserNodesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesPost: async (apiUserNodesPostRequest?: ApiUserNodesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserNodesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register with OAuth
         * @param {ApiUserOauthPostRequest} [apiUserOauthPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserOauthPost: async (apiUserOauthPostRequest?: ApiUserOauthPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserOauthPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update User Password
         * @param {ApiUserPasswordPatchRequest} [apiUserPasswordPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPasswordPatch: async (apiUserPasswordPatchRequest?: ApiUserPasswordPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserPasswordPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset Password
         * @param {ApiUserPasswordResetPatchRequest} [apiUserPasswordResetPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPasswordResetPatch: async (apiUserPasswordResetPatchRequest?: ApiUserPasswordResetPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/password/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserPasswordResetPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request Password Reset
         * @param {ApiUserPasswordResetPostRequest} [apiUserPasswordResetPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPasswordResetPost: async (apiUserPasswordResetPostRequest?: ApiUserPasswordResetPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/password/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserPasswordResetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Polls
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPollsGet: async (page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/polls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Poll
         * @param {number} poll The ID of the poll or poll option
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPollsPollGet: async (poll: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poll' is not null or undefined
            assertParamExists('apiUserPollsPollGet', 'poll', poll)
            const localVarPath = `/api/user/polls/{poll}`
                .replace(`{${"poll"}}`, encodeURIComponent(String(poll)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke Vote on Poll
         * @param {number} poll The ID of the poll or poll option
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPollsPollVoteDelete: async (poll: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poll' is not null or undefined
            assertParamExists('apiUserPollsPollVoteDelete', 'poll', poll)
            const localVarPath = `/api/user/polls/{poll}/vote`
                .replace(`{${"poll"}}`, encodeURIComponent(String(poll)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Vote on Poll
         * @param {number} poll The ID of the poll or poll option
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPollsPollVotePost: async (poll: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poll' is not null or undefined
            assertParamExists('apiUserPollsPollVotePost', 'poll', poll)
            const localVarPath = `/api/user/polls/{poll}/vote`
                .replace(`{${"poll"}}`, encodeURIComponent(String(poll)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register
         * @param {ApiUserPostRequest} [apiUserPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPost: async (apiUserPostRequest?: ApiUserPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Servers
         * @param {ApiUserServersGetTypeEnum} type The type of servers to get
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserServersGet: async (type: ApiUserServersGetTypeEnum, page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('apiUserServersGet', 'type', type)
            const localVarPath = `/api/user/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Server
         * @param {ApiUserServersPostRequest} [apiUserServersPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserServersPost: async (apiUserServersPostRequest?: ApiUserServersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserServersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server Templates Autocomplete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserServersTemplatesAutocompleteGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/servers/templates/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Server Templates
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserServersTemplatesGet: async (page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/servers/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete multiple sessions
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSessionsDelete: async (apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerSubusersDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Paginated Sessions
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSessionsGet: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Session
         * @param {number} session The ID of the session to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSessionsSessionDelete: async (session: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('apiUserSessionsSessionDelete', 'session', session)
            const localVarPath = `/api/user/sessions/{session}`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Session
         * @param {number} session The ID of the session to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSessionsSessionGet: async (session: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('apiUserSessionsSessionGet', 'session', session)
            const localVarPath = `/api/user/sessions/{session}`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete SSH Keys
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSshKeysDelete: async (apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/ssh-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerSubusersDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SSH Keys
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSshKeysGet: async (page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/ssh-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create SSH Key
         * @param {ApiUserSshKeysPostRequest} [apiUserSshKeysPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSshKeysPost: async (apiUserSshKeysPostRequest?: ApiUserSshKeysPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/ssh-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserSshKeysPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete SSH Key
         * @param {number} sshKey The ID of the ssh key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSshKeysSshKeyDelete: async (sshKey: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sshKey' is not null or undefined
            assertParamExists('apiUserSshKeysSshKeyDelete', 'sshKey', sshKey)
            const localVarPath = `/api/user/ssh-keys/{sshKey}`
                .replace(`{${"sshKey"}}`, encodeURIComponent(String(sshKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close Tickets
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTicketsClosePost: async (apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/tickets/close`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiServerServerSubusersDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Tickets
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTicketsGet: async (page?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Ticket
         * @param {ApiUserTicketsPostRequest} [apiUserTicketsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTicketsPost: async (apiUserTicketsPostRequest?: ApiUserTicketsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUserTicketsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close Tickets
         * @param {number} ticket The ID of the Ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTicketsTicketClosePost: async (ticket: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticket' is not null or undefined
            assertParamExists('apiUserTicketsTicketClosePost', 'ticket', ticket)
            const localVarPath = `/api/user/tickets/{ticket}/close`
                .replace(`{${"ticket"}}`, encodeURIComponent(String(ticket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Ticket
         * @param {number} ticket The ID of the Ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTicketsTicketGet: async (ticket: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticket' is not null or undefined
            assertParamExists('apiUserTicketsTicketGet', 'ticket', ticket)
            const localVarPath = `/api/user/tickets/{ticket}`
                .replace(`{${"ticket"}}`, encodeURIComponent(String(ticket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Ticket Messages
         * @param {number} ticket The ID of the Ticket
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTicketsTicketMessagesGet: async (ticket: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticket' is not null or undefined
            assertParamExists('apiUserTicketsTicketMessagesGet', 'ticket', ticket)
            const localVarPath = `/api/user/tickets/{ticket}/messages`
                .replace(`{${"ticket"}}`, encodeURIComponent(String(ticket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send Friend Request
         * @param {string} user The handle of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserUserFriendPost: async (user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('apiUserUserFriendPost', 'user', user)
            const localVarPath = `/api/user/{user}/friend`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get User Information
         * @param {string} user The User Handle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserUserGet: async (user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('apiUserUserGet', 'user', user)
            const localVarPath = `/api/user/@{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Admin Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAdminGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAdminGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAdminGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiAdminGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Polls
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAdminPollsGet(page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAdminPollsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAdminPollsGet(page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiAdminPollsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Poll
         * @param {number} poll The ID of the poll
         * @param {ApiAdminPollsPollPatchRequest} [apiAdminPollsPollPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAdminPollsPollPatch(poll: number, apiAdminPollsPollPatchRequest?: ApiAdminPollsPollPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAdminPollsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAdminPollsPollPatch(poll, apiAdminPollsPollPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiAdminPollsPollPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Poll
         * @param {ApiAdminPollsPostRequest} [apiAdminPollsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAdminPollsPost(apiAdminPollsPostRequest?: ApiAdminPollsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAdminPollsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAdminPollsPost(apiAdminPollsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiAdminPollsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Tickets
         * @param {ApiAdminTicketsGetTypeEnum} type The type of tickets to get
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAdminTicketsGet(type: ApiAdminTicketsGetTypeEnum, page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAdminTicketsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAdminTicketsGet(type, page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiAdminTicketsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHooksOauthDiscordGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiHooksOauthDiscordGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiHooksOauthDiscordGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHooksOauthGithubGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiHooksOauthGithubGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiHooksOauthGithubGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHooksOauthGoogleGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiHooksOauthGoogleGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiHooksOauthGoogleGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHooksPaypalCancelGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiHooksPaypalCancelGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiHooksPaypalCancelGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHooksPaypalReturnGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiHooksPaypalReturnGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiHooksPaypalReturnGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Global Infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInfosGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInfosGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInfosGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiInfosGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Node Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNodeInfosGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiNodeInfosGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNodeInfosGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiNodeInfosGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Server Allocations
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNodeServerServerAllocationsGet(server: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiNodeServerServerAllocationsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNodeServerServerAllocationsGet(server, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiNodeServerServerAllocationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Archive Status
         * @param {number} server The ID of the server
         * @param {ApiNodeServerServerFilesPullPostRequest} [apiNodeServerServerFilesPullPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNodeServerServerFilesArchivePost(server: number, apiNodeServerServerFilesPullPostRequest?: ApiNodeServerServerFilesPullPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNodeServerServerFilesArchivePost(server, apiNodeServerServerFilesPullPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiNodeServerServerFilesArchivePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Pull Status
         * @param {number} server The ID of the server
         * @param {ApiNodeServerServerFilesPullPostRequest} [apiNodeServerServerFilesPullPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNodeServerServerFilesPullPost(server: number, apiNodeServerServerFilesPullPostRequest?: ApiNodeServerServerFilesPullPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNodeServerServerFilesPullPost(server, apiNodeServerServerFilesPullPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiNodeServerServerFilesPullPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate Server SSH Credentials
         * @param {number} server The ID of the server
         * @param {ApiNodeServerServerSshPostRequest} [apiNodeServerServerSshPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNodeServerServerSshPost(server: number, apiNodeServerServerSshPostRequest?: ApiNodeServerServerSshPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiNodeServerServerSshPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNodeServerServerSshPost(server, apiNodeServerServerSshPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiNodeServerServerSshPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Server State
         * @param {number} server The ID of the server
         * @param {ApiNodeServerServerStatePostRequest} [apiNodeServerServerStatePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNodeServerServerStatePost(server: number, apiNodeServerServerStatePostRequest?: ApiNodeServerServerStatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiNodeServerServerStatePost(server, apiNodeServerServerStatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiNodeServerServerStatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get OpenAPI Docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOpenapiGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOpenapiGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiOpenapiGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all available permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPermissionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiPermissionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPermissionsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiPermissionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Polls
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPollsGet(page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAdminPollsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPollsGet(page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiPollsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Poll
         * @param {number} poll The Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPollsPollGet(poll: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiPollsPollGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPollsPollGet(poll, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiPollsPollGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Server Actions
         * @param {number} server The ID of the server
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerActionLogsGet(server: number, page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerActionLogsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerActionLogsGet(server, page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerActionLogsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Server Allocation
         * @param {number} server The ID of the server
         * @param {number} allocation The ID of the allocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerAllocationsAllocationDelete(server: number, allocation: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerAllocationsAllocationDelete(server, allocation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerAllocationsAllocationDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Server Allocation
         * @param {number} server The ID of the server
         * @param {number} allocation The ID of the allocation
         * @param {ApiServerServerAllocationsAllocationPatchRequest} [apiServerServerAllocationsAllocationPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerAllocationsAllocationPatch(server: number, allocation: number, apiServerServerAllocationsAllocationPatchRequest?: ApiServerServerAllocationsAllocationPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerAllocationsAllocationPatch(server, allocation, apiServerServerAllocationsAllocationPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerAllocationsAllocationPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Server Node Allocations Autocomplete
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerAllocationsAutocompleteGet(server: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerAllocationsAutocompleteGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerAllocationsAutocompleteGet(server, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerAllocationsAutocompleteGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Server Allocations
         * @param {number} server The ID of the server
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerAllocationsDelete(server: number, apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesDeletePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerAllocationsDelete(server, apiServerServerSubusersDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerAllocationsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Server Allocations
         * @param {number} server The ID of the server
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerAllocationsGet(server: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerAllocationsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerAllocationsGet(server, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerAllocationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Server Allocation
         * @param {number} server The ID of the server
         * @param {ApiServerServerAllocationsPostRequest} [apiServerServerAllocationsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerAllocationsPost(server: number, apiServerServerAllocationsPostRequest?: ApiServerServerAllocationsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerAllocationsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerAllocationsPost(server, apiServerServerAllocationsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerAllocationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Server
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerDelete(server: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerDelete(server, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Abort Server File Archive Operation
         * @param {number} server The ID of the server
         * @param {number} archive The ID of the archive operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerFilesArchivesArchiveDelete(server: number, archive: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerFilesArchivesArchiveDelete(server, archive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerFilesArchivesArchiveDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Server Archive Operations
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerFilesArchivesGet(server: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesArchivesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerFilesArchivesGet(server, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerFilesArchivesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Archive Server Files
         * @param {number} server The ID of the server
         * @param {string} path The path to the file or directory
         * @param {ApiServerServerFilesArchivesPostRequest} [apiServerServerFilesArchivesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerFilesArchivesPost(server: number, path: string, apiServerServerFilesArchivesPostRequest?: ApiServerServerFilesArchivesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesArchivesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerFilesArchivesPost(server, path, apiServerServerFilesArchivesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerFilesArchivesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Server Files
         * @param {number} server The ID of the server
         * @param {ApiServerServerFilesDeletePostRequest} [apiServerServerFilesDeletePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerFilesDeletePost(server: number, apiServerServerFilesDeletePostRequest?: ApiServerServerFilesDeletePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesDeletePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerFilesDeletePost(server, apiServerServerFilesDeletePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerFilesDeletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Server Files
         * @param {number} server The ID of the server
         * @param {string} path The path to the file or directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerFilesGet(server: number, path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerFilesGet(server, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerFilesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Server File Hashes
         * @param {number} server The ID of the server
         * @param {string} path The path to the file or directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerFilesHashGet(server: number, path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesHashGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerFilesHashGet(server, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerFilesHashGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Server File Pulls
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerFilesPullsGet(server: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerFilesPullsGet(server, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerFilesPullsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Pull Server File
         * @param {number} server The ID of the server
         * @param {string} path The path to the file or directory
         * @param {ApiServerServerFilesPullsPostRequest} [apiServerServerFilesPullsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerFilesPullsPost(server: number, path: string, apiServerServerFilesPullsPostRequest?: ApiServerServerFilesPullsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerFilesPullsPost(server, path, apiServerServerFilesPullsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerFilesPullsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Abort Server File Pull
         * @param {number} server The ID of the server
         * @param {number} pull The ID of the pull
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerFilesPullsPullDelete(server: number, pull: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerFilesPullsPullDelete(server, pull, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerFilesPullsPullDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Server
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerGet(server: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerGet(server, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Server Icon
         * @param {number} server The ID of the server
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerIconPost(server: number, body?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerIconPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerIconPost(server, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerIconPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Server
         * @param {number} server The ID of the server
         * @param {ApiServerServerPatchRequest} [apiServerServerPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerPatch(server: number, apiServerServerPatchRequest?: ApiServerServerPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerPatch(server, apiServerServerPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Server Disk
         * @param {number} server The ID of the server
         * @param {ApiServerServerResourcesDiskPatchRequest} [apiServerServerResourcesDiskPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerResourcesDiskPatch(server: number, apiServerServerResourcesDiskPatchRequest?: ApiServerServerResourcesDiskPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerResourcesDiskPatch(server, apiServerServerResourcesDiskPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerResourcesDiskPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Server Resources
         * @param {number} server The ID of the server
         * @param {ApiServerServerResourcesPatchRequest} [apiServerServerResourcesPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerResourcesPatch(server: number, apiServerServerResourcesPatchRequest?: ApiServerServerResourcesPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerResourcesPatch(server, apiServerServerResourcesPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerResourcesPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Server SSH Info
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerSshGet(server: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerSshGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerSshGet(server, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerSshGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Server Stats
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerStatsGet(server: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerStatsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerStatsGet(server, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Server Status
         * @param {number} server The ID of the server
         * @param {ApiServerServerStatusPostRequest} [apiServerServerStatusPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerStatusPost(server: number, apiServerServerStatusPostRequest?: ApiServerServerStatusPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerStatusPost(server, apiServerServerStatusPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerStatusPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Subusers
         * @param {number} server The ID of the server
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerSubusersDelete(server: number, apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesDeletePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerSubusersDelete(server, apiServerServerSubusersDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerSubusersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Subusers
         * @param {number} server The ID of the server
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerSubusersGet(server: number, page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerSubusersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerSubusersGet(server, page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerSubusersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Subuser
         * @param {number} server The ID of the server
         * @param {ApiServerServerSubusersPostRequest} [apiServerServerSubusersPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerSubusersPost(server: number, apiServerServerSubusersPostRequest?: ApiServerServerSubusersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerSubusersPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerSubusersPost(server, apiServerServerSubusersPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerSubusersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Subuser
         * @param {number} server The ID of the server
         * @param {number} subuser The ID of the subuser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerSubusersSubuserDelete(server: number, subuser: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerSubusersSubuserDelete(server, subuser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerSubusersSubuserDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Subuser
         * @param {number} server The ID of the server
         * @param {number} subuser The ID of the subuser
         * @param {ApiServerServerSubusersSubuserPatchRequest} [apiServerServerSubusersSubuserPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiServerServerSubusersSubuserPatch(server: number, subuser: number, apiServerServerSubusersSubuserPatchRequest?: ApiServerServerSubusersSubuserPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiServerServerSubusersSubuserPatch(server, subuser, apiServerServerSubusersSubuserPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiServerServerSubusersSubuserPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable 2FA on the account
         * @param {ApiUser2faDeleteRequest} [apiUser2faDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUser2faDelete(apiUser2faDeleteRequest?: ApiUser2faDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUser2faDelete(apiUser2faDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUser2faDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUser2faGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUser2faGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUser2faGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUser2faGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable 2FA
         * @param {ApiUser2faPostRequest} [apiUser2faPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUser2faPost(apiUser2faPostRequest?: ApiUser2faPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUser2faPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUser2faPost(apiUser2faPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUser2faPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Account Actions
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserActionLogsGet(page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserActionLogsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserActionLogsGet(page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserActionLogsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete API Key
         * @param {number} apiKey The ID of the api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserApiKeysApiKeyDelete(apiKey: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserApiKeysApiKeyDelete(apiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserApiKeysApiKeyDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update API Key
         * @param {number} apiKey The ID of the api key
         * @param {ApiUserApiKeysApiKeyPatchRequest} [apiUserApiKeysApiKeyPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserApiKeysApiKeyPatch(apiKey: number, apiUserApiKeysApiKeyPatchRequest?: ApiUserApiKeysApiKeyPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserApiKeysApiKeyPatch(apiKey, apiUserApiKeysApiKeyPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserApiKeysApiKeyPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset API Key
         * @param {number} apiKey The ID of the api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserApiKeysApiKeyResetKeyPost(apiKey: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserApiKeysApiKeyResetKeyPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserApiKeysApiKeyResetKeyPost(apiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserApiKeysApiKeyResetKeyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete API Keys
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserApiKeysDelete(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesDeletePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserApiKeysDelete(apiServerServerSubusersDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserApiKeysDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get API Keys
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserApiKeysGet(page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserApiKeysGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserApiKeysGet(page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserApiKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create API Key
         * @param {ApiUserApiKeysPostRequest} [apiUserApiKeysPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserApiKeysPost(apiUserApiKeysPostRequest?: ApiUserApiKeysPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserApiKeysApiKeyResetKeyPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserApiKeysPost(apiUserApiKeysPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserApiKeysPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update User Avatar
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserAvatarPost(body?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerIconPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserAvatarPost(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserAvatarPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove Connection
         * @param {ApiUserConnectionsAppDeleteAppEnum} app The app to remove the connection from
         * @param {ApiUserConnectionsAppDeleteRequest} [apiUserConnectionsAppDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserConnectionsAppDelete(app: ApiUserConnectionsAppDeleteAppEnum, apiUserConnectionsAppDeleteRequest?: ApiUserConnectionsAppDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserConnectionsAppDelete(app, apiUserConnectionsAppDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserConnectionsAppDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Connection Infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserConnectionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserConnectionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserConnectionsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserConnectionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the User Email
         * @param {ApiUserEmailPatchRequest} [apiUserEmailPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserEmailPatch(apiUserEmailPatchRequest?: ApiUserEmailPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserEmailPatch(apiUserEmailPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserEmailPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify the User Email
         * @param {ApiUserEmailVerifyPostRequest} [apiUserEmailVerifyPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserEmailVerifyPost(apiUserEmailVerifyPostRequest?: ApiUserEmailVerifyPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserEmailVerifyPost(apiUserEmailVerifyPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserEmailVerifyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accept Friend Requests
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFriendsAcceptPost(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesDeletePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFriendsAcceptPost(apiServerServerSubusersDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserFriendsAcceptPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove Friends
         * @param {ApiUserFriendsDeleteRequest} [apiUserFriendsDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFriendsDelete(apiUserFriendsDeleteRequest?: ApiUserFriendsDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserFriendsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFriendsDelete(apiUserFriendsDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserFriendsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Friends
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFriendsGet(page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserFriendsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFriendsGet(page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserFriendsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable Incoming Friend Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFriendsIncomingDisablePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFriendsIncomingDisablePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserFriendsIncomingDisablePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable Incoming Friend Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFriendsIncomingEnablePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFriendsIncomingEnablePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserFriendsIncomingEnablePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Pending Friends
         * @param {ApiUserFriendsPendingGetTypeEnum} type The type of pending friends to get
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFriendsPendingGet(type: ApiUserFriendsPendingGetTypeEnum, page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserFriendsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFriendsPendingGet(type, page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserFriendsPendingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accept Friend Request
         * @param {number} user The ID of the friend request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFriendsUserAcceptPost(user: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFriendsUserAcceptPost(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserFriendsUserAcceptPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove Friend
         * @param {number} user The ID of the friend request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFriendsUserDelete(user: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFriendsUserDelete(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserFriendsUserDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Invoices
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserInvoicesCancelPost(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesDeletePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserInvoicesCancelPost(apiServerServerSubusersDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserInvoicesCancelPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Invoices
         * @param {number} [page] 
         * @param {ApiUserInvoicesGetTypeEnum} [type] The type of invoices to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserInvoicesGet(page?: number, type?: ApiUserInvoicesGetTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserInvoicesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserInvoicesGet(page, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserInvoicesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel Invoice
         * @param {number} invoice The ID of the invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserInvoicesInvoiceCancelPost(invoice: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserInvoicesInvoiceCancelPost(invoice, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserInvoicesInvoiceCancelPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Pay Invoice
         * @param {number} invoice The ID of the invoice
         * @param {ApiUserInvoicesInvoicePayPostRequest} [apiUserInvoicesInvoicePayPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserInvoicesInvoicePayPost(invoice: number, apiUserInvoicesInvoicePayPostRequest?: ApiUserInvoicesInvoicePayPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserInvoicesInvoicePayPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserInvoicesInvoicePayPost(invoice, apiUserInvoicesInvoicePayPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserInvoicesInvoicePayPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Invoice
         * @param {ApiUserInvoicesPostRequest} [apiUserInvoicesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserInvoicesPost(apiUserInvoicesPostRequest?: ApiUserInvoicesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserInvoicesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserInvoicesPost(apiUserInvoicesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserInvoicesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Invoice Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserInvoicesStatsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserInvoicesStatsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserInvoicesStatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserInvoicesStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login with Two Factor
         * @param {ApiUserLogin2faPostRequest} [apiUserLogin2faPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserLogin2faPost(apiUserLogin2faPostRequest?: ApiUserLogin2faPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserLogin2faPost(apiUserLogin2faPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserLogin2faPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * OAuth2 Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserLoginOauthPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserLoginPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserLoginOauthPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserLoginOauthPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Login
         * @param {ApiUserLoginPostRequest} [apiUserLoginPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserLoginPost(apiUserLoginPostRequest?: ApiUserLoginPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserLoginPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserLoginPost(apiUserLoginPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserLogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserLogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete User
         * @param {ApiUserMeDeleteRequest} [apiUserMeDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserMeDelete(apiUserMeDeleteRequest?: ApiUserMeDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserMeDelete(apiUserMeDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserMeDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserMeGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update User
         * @param {ApiUserMePatchRequest} [apiUserMePatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserMePatch(apiUserMePatchRequest?: ApiUserMePatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserMePatch(apiUserMePatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserMePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Nodes Autocomplete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserNodesAutocompleteGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserNodesAutocompleteGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserNodesAutocompleteGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserNodesAutocompleteGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Nodes
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserNodesGet(page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserNodesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserNodesGet(page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserNodesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Node Allocation
         * @param {number} node The ID of the node
         * @param {number} allocation The ID of the allocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserNodesNodeAllocationsAllocationDelete(node: number, allocation: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserNodesNodeAllocationsAllocationDelete(node, allocation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserNodesNodeAllocationsAllocationDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Node Allocation
         * @param {number} node The ID of the node
         * @param {number} allocation The ID of the allocation
         * @param {ApiUserNodesNodeAllocationsAllocationPatchRequest} [apiUserNodesNodeAllocationsAllocationPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserNodesNodeAllocationsAllocationPatch(node: number, allocation: number, apiUserNodesNodeAllocationsAllocationPatchRequest?: ApiUserNodesNodeAllocationsAllocationPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserNodesNodeAllocationsAllocationPatch(node, allocation, apiUserNodesNodeAllocationsAllocationPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserNodesNodeAllocationsAllocationPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Node Allocations
         * @param {number} node The ID of the node
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserNodesNodeAllocationsDelete(node: number, apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesDeletePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserNodesNodeAllocationsDelete(node, apiServerServerSubusersDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserNodesNodeAllocationsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Node Allocations
         * @param {number} node The ID of the node
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserNodesNodeAllocationsGet(node: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserNodesNodeAllocationsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserNodesNodeAllocationsGet(node, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserNodesNodeAllocationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Node Allocation
         * @param {number} node The ID of the node
         * @param {ApiUserNodesNodeAllocationsPostRequest} [apiUserNodesNodeAllocationsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserNodesNodeAllocationsPost(node: number, apiUserNodesNodeAllocationsPostRequest?: ApiUserNodesNodeAllocationsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserNodesNodeAllocationsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserNodesNodeAllocationsPost(node, apiUserNodesNodeAllocationsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserNodesNodeAllocationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Node
         * @param {number} node The ID of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserNodesNodeDelete(node: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserNodesNodeDelete(node, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserNodesNodeDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Node
         * @param {number} node The ID of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserNodesNodeGet(node: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserNodesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserNodesNodeGet(node, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserNodesNodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update Node
         * @param {number} node The ID of the node
         * @param {ApiUserNodesNodePatchRequest} [apiUserNodesNodePatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserNodesNodePatch(node: number, apiUserNodesNodePatchRequest?: ApiUserNodesNodePatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserNodesNodePatch(node, apiUserNodesNodePatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserNodesNodePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset Node Key
         * @param {number} node The ID of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserNodesNodeResetKeyPost(node: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserNodesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserNodesNodeResetKeyPost(node, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserNodesNodeResetKeyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Node Stats
         * @param {number} node The ID of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserNodesNodeStatsGet(node: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserNodesNodeStatsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserNodesNodeStatsGet(node, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserNodesNodeStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Node
         * @param {ApiUserNodesPostRequest} [apiUserNodesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserNodesPost(apiUserNodesPostRequest?: ApiUserNodesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserNodesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserNodesPost(apiUserNodesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserNodesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register with OAuth
         * @param {ApiUserOauthPostRequest} [apiUserOauthPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserOauthPost(apiUserOauthPostRequest?: ApiUserOauthPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserOauthPost(apiUserOauthPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserOauthPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update User Password
         * @param {ApiUserPasswordPatchRequest} [apiUserPasswordPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPasswordPatch(apiUserPasswordPatchRequest?: ApiUserPasswordPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAdminPollsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPasswordPatch(apiUserPasswordPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserPasswordPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset Password
         * @param {ApiUserPasswordResetPatchRequest} [apiUserPasswordResetPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPasswordResetPatch(apiUserPasswordResetPatchRequest?: ApiUserPasswordResetPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPasswordResetPatch(apiUserPasswordResetPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserPasswordResetPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request Password Reset
         * @param {ApiUserPasswordResetPostRequest} [apiUserPasswordResetPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPasswordResetPost(apiUserPasswordResetPostRequest?: ApiUserPasswordResetPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPasswordResetPost(apiUserPasswordResetPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserPasswordResetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Polls
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPollsGet(page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAdminPollsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPollsGet(page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserPollsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Poll
         * @param {number} poll The ID of the poll or poll option
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPollsPollGet(poll: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiPollsPollGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPollsPollGet(poll, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserPollsPollGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke Vote on Poll
         * @param {number} poll The ID of the poll or poll option
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPollsPollVoteDelete(poll: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPollsPollVoteDelete(poll, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserPollsPollVoteDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Vote on Poll
         * @param {number} poll The ID of the poll or poll option
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPollsPollVotePost(poll: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPollsPollVotePost(poll, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserPollsPollVotePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register
         * @param {ApiUserPostRequest} [apiUserPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPost(apiUserPostRequest?: ApiUserPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPost(apiUserPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Servers
         * @param {ApiUserServersGetTypeEnum} type The type of servers to get
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserServersGet(type: ApiUserServersGetTypeEnum, page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserServersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserServersGet(type, page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserServersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Server
         * @param {ApiUserServersPostRequest} [apiUserServersPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserServersPost(apiUserServersPostRequest?: ApiUserServersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserServersPost(apiUserServersPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserServersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Server Templates Autocomplete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserServersTemplatesAutocompleteGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserServersTemplatesAutocompleteGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserServersTemplatesAutocompleteGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserServersTemplatesAutocompleteGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Server Templates
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserServersTemplatesGet(page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserServersTemplatesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserServersTemplatesGet(page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserServersTemplatesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete multiple sessions
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSessionsDelete(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesDeletePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSessionsDelete(apiServerServerSubusersDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserSessionsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Paginated Sessions
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSessionsGet(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserSessionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSessionsGet(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserSessionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Session
         * @param {number} session The ID of the session to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSessionsSessionDelete(session: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSessionsSessionDelete(session, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserSessionsSessionDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Session
         * @param {number} session The ID of the session to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSessionsSessionGet(session: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserSessionsSessionGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSessionsSessionGet(session, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserSessionsSessionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete SSH Keys
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSshKeysDelete(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesDeletePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSshKeysDelete(apiServerServerSubusersDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserSshKeysDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SSH Keys
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSshKeysGet(page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserSshKeysGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSshKeysGet(page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserSshKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create SSH Key
         * @param {ApiUserSshKeysPostRequest} [apiUserSshKeysPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSshKeysPost(apiUserSshKeysPostRequest?: ApiUserSshKeysPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserSshKeysPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSshKeysPost(apiUserSshKeysPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserSshKeysPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete SSH Key
         * @param {number} sshKey The ID of the ssh key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSshKeysSshKeyDelete(sshKey: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSshKeysSshKeyDelete(sshKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserSshKeysSshKeyDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close Tickets
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserTicketsClosePost(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesDeletePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserTicketsClosePost(apiServerServerSubusersDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserTicketsClosePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Tickets
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserTicketsGet(page?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAdminTicketsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserTicketsGet(page, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserTicketsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Ticket
         * @param {ApiUserTicketsPostRequest} [apiUserTicketsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserTicketsPost(apiUserTicketsPostRequest?: ApiUserTicketsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserTicketsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserTicketsPost(apiUserTicketsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserTicketsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Close Tickets
         * @param {number} ticket The ID of the Ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserTicketsTicketClosePost(ticket: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserTicketsTicketClosePost(ticket, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserTicketsTicketClosePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Ticket
         * @param {number} ticket The ID of the Ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserTicketsTicketGet(ticket: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserTicketsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserTicketsTicketGet(ticket, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserTicketsTicketGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Ticket Messages
         * @param {number} ticket The ID of the Ticket
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserTicketsTicketMessagesGet(ticket: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserTicketsTicketMessagesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserTicketsTicketMessagesGet(ticket, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserTicketsTicketMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send Friend Request
         * @param {string} user The handle of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserUserFriendPost(user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiServerServerFilesPullsPullDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserUserFriendPost(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserUserFriendPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get User Information
         * @param {string} user The User Handle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserUserGet(user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserUserGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserUserGet(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.apiUserUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Get Admin Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminGet(options?: any): AxiosPromise<ApiAdminGet200Response> {
            return localVarFp.apiAdminGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Polls
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminPollsGet(page?: number, search?: string, options?: any): AxiosPromise<ApiAdminPollsGet200Response> {
            return localVarFp.apiAdminPollsGet(page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Poll
         * @param {number} poll The ID of the poll
         * @param {ApiAdminPollsPollPatchRequest} [apiAdminPollsPollPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminPollsPollPatch(poll: number, apiAdminPollsPollPatchRequest?: ApiAdminPollsPollPatchRequest, options?: any): AxiosPromise<ApiAdminPollsPost200Response> {
            return localVarFp.apiAdminPollsPollPatch(poll, apiAdminPollsPollPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create Poll
         * @param {ApiAdminPollsPostRequest} [apiAdminPollsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminPollsPost(apiAdminPollsPostRequest?: ApiAdminPollsPostRequest, options?: any): AxiosPromise<ApiAdminPollsPost200Response> {
            return localVarFp.apiAdminPollsPost(apiAdminPollsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Tickets
         * @param {ApiAdminTicketsGetTypeEnum} type The type of tickets to get
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminTicketsGet(type: ApiAdminTicketsGetTypeEnum, page?: number, search?: string, options?: any): AxiosPromise<ApiAdminTicketsGet200Response> {
            return localVarFp.apiAdminTicketsGet(type, page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksOauthDiscordGet(options?: any): AxiosPromise<void> {
            return localVarFp.apiHooksOauthDiscordGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksOauthGithubGet(options?: any): AxiosPromise<void> {
            return localVarFp.apiHooksOauthGithubGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksOauthGoogleGet(options?: any): AxiosPromise<void> {
            return localVarFp.apiHooksOauthGoogleGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksPaypalCancelGet(options?: any): AxiosPromise<void> {
            return localVarFp.apiHooksPaypalCancelGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksPaypalReturnGet(options?: any): AxiosPromise<void> {
            return localVarFp.apiHooksPaypalReturnGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Global Infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInfosGet(options?: any): AxiosPromise<ApiInfosGet200Response> {
            return localVarFp.apiInfosGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Node Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNodeInfosGet(options?: any): AxiosPromise<ApiNodeInfosGet200Response> {
            return localVarFp.apiNodeInfosGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Server Allocations
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNodeServerServerAllocationsGet(server: number, options?: any): AxiosPromise<ApiNodeServerServerAllocationsGet200Response> {
            return localVarFp.apiNodeServerServerAllocationsGet(server, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Archive Status
         * @param {number} server The ID of the server
         * @param {ApiNodeServerServerFilesPullPostRequest} [apiNodeServerServerFilesPullPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNodeServerServerFilesArchivePost(server: number, apiNodeServerServerFilesPullPostRequest?: ApiNodeServerServerFilesPullPostRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiNodeServerServerFilesArchivePost(server, apiNodeServerServerFilesPullPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Pull Status
         * @param {number} server The ID of the server
         * @param {ApiNodeServerServerFilesPullPostRequest} [apiNodeServerServerFilesPullPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNodeServerServerFilesPullPost(server: number, apiNodeServerServerFilesPullPostRequest?: ApiNodeServerServerFilesPullPostRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiNodeServerServerFilesPullPost(server, apiNodeServerServerFilesPullPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate Server SSH Credentials
         * @param {number} server The ID of the server
         * @param {ApiNodeServerServerSshPostRequest} [apiNodeServerServerSshPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNodeServerServerSshPost(server: number, apiNodeServerServerSshPostRequest?: ApiNodeServerServerSshPostRequest, options?: any): AxiosPromise<ApiNodeServerServerSshPost200Response> {
            return localVarFp.apiNodeServerServerSshPost(server, apiNodeServerServerSshPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Server State
         * @param {number} server The ID of the server
         * @param {ApiNodeServerServerStatePostRequest} [apiNodeServerServerStatePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNodeServerServerStatePost(server: number, apiNodeServerServerStatePostRequest?: ApiNodeServerServerStatePostRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiNodeServerServerStatePost(server, apiNodeServerServerStatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get OpenAPI Docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOpenapiGet(options?: any): AxiosPromise<void> {
            return localVarFp.apiOpenapiGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all available permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPermissionsGet(options?: any): AxiosPromise<ApiPermissionsGet200Response> {
            return localVarFp.apiPermissionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Polls
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPollsGet(page?: number, search?: string, options?: any): AxiosPromise<ApiAdminPollsGet200Response> {
            return localVarFp.apiPollsGet(page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Poll
         * @param {number} poll The Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPollsPollGet(poll: number, options?: any): AxiosPromise<ApiPollsPollGet200Response> {
            return localVarFp.apiPollsPollGet(poll, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Server Actions
         * @param {number} server The ID of the server
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerActionLogsGet(server: number, page?: number, search?: string, options?: any): AxiosPromise<ApiServerServerActionLogsGet200Response> {
            return localVarFp.apiServerServerActionLogsGet(server, page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Server Allocation
         * @param {number} server The ID of the server
         * @param {number} allocation The ID of the allocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerAllocationsAllocationDelete(server: number, allocation: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiServerServerAllocationsAllocationDelete(server, allocation, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Server Allocation
         * @param {number} server The ID of the server
         * @param {number} allocation The ID of the allocation
         * @param {ApiServerServerAllocationsAllocationPatchRequest} [apiServerServerAllocationsAllocationPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerAllocationsAllocationPatch(server: number, allocation: number, apiServerServerAllocationsAllocationPatchRequest?: ApiServerServerAllocationsAllocationPatchRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiServerServerAllocationsAllocationPatch(server, allocation, apiServerServerAllocationsAllocationPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Server Node Allocations Autocomplete
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerAllocationsAutocompleteGet(server: number, options?: any): AxiosPromise<ApiServerServerAllocationsAutocompleteGet200Response> {
            return localVarFp.apiServerServerAllocationsAutocompleteGet(server, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Server Allocations
         * @param {number} server The ID of the server
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerAllocationsDelete(server: number, apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: any): AxiosPromise<ApiServerServerFilesDeletePost200Response> {
            return localVarFp.apiServerServerAllocationsDelete(server, apiServerServerSubusersDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Server Allocations
         * @param {number} server The ID of the server
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerAllocationsGet(server: number, page?: number, options?: any): AxiosPromise<ApiServerServerAllocationsGet200Response> {
            return localVarFp.apiServerServerAllocationsGet(server, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Create Server Allocation
         * @param {number} server The ID of the server
         * @param {ApiServerServerAllocationsPostRequest} [apiServerServerAllocationsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerAllocationsPost(server: number, apiServerServerAllocationsPostRequest?: ApiServerServerAllocationsPostRequest, options?: any): AxiosPromise<ApiServerServerAllocationsPost200Response> {
            return localVarFp.apiServerServerAllocationsPost(server, apiServerServerAllocationsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Server
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerDelete(server: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiServerServerDelete(server, options).then((request) => request(axios, basePath));
        },
        /**
         * Abort Server File Archive Operation
         * @param {number} server The ID of the server
         * @param {number} archive The ID of the archive operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesArchivesArchiveDelete(server: number, archive: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiServerServerFilesArchivesArchiveDelete(server, archive, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Server Archive Operations
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesArchivesGet(server: number, options?: any): AxiosPromise<ApiServerServerFilesArchivesGet200Response> {
            return localVarFp.apiServerServerFilesArchivesGet(server, options).then((request) => request(axios, basePath));
        },
        /**
         * Archive Server Files
         * @param {number} server The ID of the server
         * @param {string} path The path to the file or directory
         * @param {ApiServerServerFilesArchivesPostRequest} [apiServerServerFilesArchivesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesArchivesPost(server: number, path: string, apiServerServerFilesArchivesPostRequest?: ApiServerServerFilesArchivesPostRequest, options?: any): AxiosPromise<ApiServerServerFilesArchivesPost200Response> {
            return localVarFp.apiServerServerFilesArchivesPost(server, path, apiServerServerFilesArchivesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Server Files
         * @param {number} server The ID of the server
         * @param {ApiServerServerFilesDeletePostRequest} [apiServerServerFilesDeletePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesDeletePost(server: number, apiServerServerFilesDeletePostRequest?: ApiServerServerFilesDeletePostRequest, options?: any): AxiosPromise<ApiServerServerFilesDeletePost200Response> {
            return localVarFp.apiServerServerFilesDeletePost(server, apiServerServerFilesDeletePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Server Files
         * @param {number} server The ID of the server
         * @param {string} path The path to the file or directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesGet(server: number, path: string, options?: any): AxiosPromise<ApiServerServerFilesGet200Response> {
            return localVarFp.apiServerServerFilesGet(server, path, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Server File Hashes
         * @param {number} server The ID of the server
         * @param {string} path The path to the file or directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesHashGet(server: number, path: string, options?: any): AxiosPromise<ApiServerServerFilesHashGet200Response> {
            return localVarFp.apiServerServerFilesHashGet(server, path, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Server File Pulls
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesPullsGet(server: number, options?: any): AxiosPromise<ApiServerServerFilesPullsGet200Response> {
            return localVarFp.apiServerServerFilesPullsGet(server, options).then((request) => request(axios, basePath));
        },
        /**
         * Pull Server File
         * @param {number} server The ID of the server
         * @param {string} path The path to the file or directory
         * @param {ApiServerServerFilesPullsPostRequest} [apiServerServerFilesPullsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesPullsPost(server: number, path: string, apiServerServerFilesPullsPostRequest?: ApiServerServerFilesPullsPostRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPost200Response> {
            return localVarFp.apiServerServerFilesPullsPost(server, path, apiServerServerFilesPullsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Abort Server File Pull
         * @param {number} server The ID of the server
         * @param {number} pull The ID of the pull
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerFilesPullsPullDelete(server: number, pull: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiServerServerFilesPullsPullDelete(server, pull, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Server
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerGet(server: number, options?: any): AxiosPromise<ApiServerServerGet200Response> {
            return localVarFp.apiServerServerGet(server, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Server Icon
         * @param {number} server The ID of the server
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerIconPost(server: number, body?: File, options?: any): AxiosPromise<ApiServerServerIconPost200Response> {
            return localVarFp.apiServerServerIconPost(server, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Server
         * @param {number} server The ID of the server
         * @param {ApiServerServerPatchRequest} [apiServerServerPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerPatch(server: number, apiServerServerPatchRequest?: ApiServerServerPatchRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiServerServerPatch(server, apiServerServerPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Server Disk
         * @param {number} server The ID of the server
         * @param {ApiServerServerResourcesDiskPatchRequest} [apiServerServerResourcesDiskPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerResourcesDiskPatch(server: number, apiServerServerResourcesDiskPatchRequest?: ApiServerServerResourcesDiskPatchRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiServerServerResourcesDiskPatch(server, apiServerServerResourcesDiskPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Server Resources
         * @param {number} server The ID of the server
         * @param {ApiServerServerResourcesPatchRequest} [apiServerServerResourcesPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerResourcesPatch(server: number, apiServerServerResourcesPatchRequest?: ApiServerServerResourcesPatchRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiServerServerResourcesPatch(server, apiServerServerResourcesPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Server SSH Info
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerSshGet(server: number, options?: any): AxiosPromise<ApiServerServerSshGet200Response> {
            return localVarFp.apiServerServerSshGet(server, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Server Stats
         * @param {number} server The ID of the server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerStatsGet(server: number, options?: any): AxiosPromise<ApiServerServerStatsGet200Response> {
            return localVarFp.apiServerServerStatsGet(server, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Server Status
         * @param {number} server The ID of the server
         * @param {ApiServerServerStatusPostRequest} [apiServerServerStatusPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerStatusPost(server: number, apiServerServerStatusPostRequest?: ApiServerServerStatusPostRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiServerServerStatusPost(server, apiServerServerStatusPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Subusers
         * @param {number} server The ID of the server
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerSubusersDelete(server: number, apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: any): AxiosPromise<ApiServerServerFilesDeletePost200Response> {
            return localVarFp.apiServerServerSubusersDelete(server, apiServerServerSubusersDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Subusers
         * @param {number} server The ID of the server
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerSubusersGet(server: number, page?: number, search?: string, options?: any): AxiosPromise<ApiServerServerSubusersGet200Response> {
            return localVarFp.apiServerServerSubusersGet(server, page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Create Subuser
         * @param {number} server The ID of the server
         * @param {ApiServerServerSubusersPostRequest} [apiServerServerSubusersPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerSubusersPost(server: number, apiServerServerSubusersPostRequest?: ApiServerServerSubusersPostRequest, options?: any): AxiosPromise<ApiServerServerSubusersPost200Response> {
            return localVarFp.apiServerServerSubusersPost(server, apiServerServerSubusersPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Subuser
         * @param {number} server The ID of the server
         * @param {number} subuser The ID of the subuser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerSubusersSubuserDelete(server: number, subuser: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiServerServerSubusersSubuserDelete(server, subuser, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Subuser
         * @param {number} server The ID of the server
         * @param {number} subuser The ID of the subuser
         * @param {ApiServerServerSubusersSubuserPatchRequest} [apiServerServerSubusersSubuserPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiServerServerSubusersSubuserPatch(server: number, subuser: number, apiServerServerSubusersSubuserPatchRequest?: ApiServerServerSubusersSubuserPatchRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiServerServerSubusersSubuserPatch(server, subuser, apiServerServerSubusersSubuserPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable 2FA on the account
         * @param {ApiUser2faDeleteRequest} [apiUser2faDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUser2faDelete(apiUser2faDeleteRequest?: ApiUser2faDeleteRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUser2faDelete(apiUser2faDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUser2faGet(options?: any): AxiosPromise<ApiUser2faGet200Response> {
            return localVarFp.apiUser2faGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Enable 2FA
         * @param {ApiUser2faPostRequest} [apiUser2faPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUser2faPost(apiUser2faPostRequest?: ApiUser2faPostRequest, options?: any): AxiosPromise<ApiUser2faPost200Response> {
            return localVarFp.apiUser2faPost(apiUser2faPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Account Actions
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserActionLogsGet(page?: number, search?: string, options?: any): AxiosPromise<ApiUserActionLogsGet200Response> {
            return localVarFp.apiUserActionLogsGet(page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete API Key
         * @param {number} apiKey The ID of the api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApiKeysApiKeyDelete(apiKey: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserApiKeysApiKeyDelete(apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update API Key
         * @param {number} apiKey The ID of the api key
         * @param {ApiUserApiKeysApiKeyPatchRequest} [apiUserApiKeysApiKeyPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApiKeysApiKeyPatch(apiKey: number, apiUserApiKeysApiKeyPatchRequest?: ApiUserApiKeysApiKeyPatchRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserApiKeysApiKeyPatch(apiKey, apiUserApiKeysApiKeyPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset API Key
         * @param {number} apiKey The ID of the api key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApiKeysApiKeyResetKeyPost(apiKey: number, options?: any): AxiosPromise<ApiUserApiKeysApiKeyResetKeyPost200Response> {
            return localVarFp.apiUserApiKeysApiKeyResetKeyPost(apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete API Keys
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApiKeysDelete(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: any): AxiosPromise<ApiServerServerFilesDeletePost200Response> {
            return localVarFp.apiUserApiKeysDelete(apiServerServerSubusersDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get API Keys
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApiKeysGet(page?: number, search?: string, options?: any): AxiosPromise<ApiUserApiKeysGet200Response> {
            return localVarFp.apiUserApiKeysGet(page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Create API Key
         * @param {ApiUserApiKeysPostRequest} [apiUserApiKeysPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApiKeysPost(apiUserApiKeysPostRequest?: ApiUserApiKeysPostRequest, options?: any): AxiosPromise<ApiUserApiKeysApiKeyResetKeyPost200Response> {
            return localVarFp.apiUserApiKeysPost(apiUserApiKeysPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update User Avatar
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserAvatarPost(body?: File, options?: any): AxiosPromise<ApiServerServerIconPost200Response> {
            return localVarFp.apiUserAvatarPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove Connection
         * @param {ApiUserConnectionsAppDeleteAppEnum} app The app to remove the connection from
         * @param {ApiUserConnectionsAppDeleteRequest} [apiUserConnectionsAppDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserConnectionsAppDelete(app: ApiUserConnectionsAppDeleteAppEnum, apiUserConnectionsAppDeleteRequest?: ApiUserConnectionsAppDeleteRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserConnectionsAppDelete(app, apiUserConnectionsAppDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Connection Infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserConnectionsGet(options?: any): AxiosPromise<ApiUserConnectionsGet200Response> {
            return localVarFp.apiUserConnectionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the User Email
         * @param {ApiUserEmailPatchRequest} [apiUserEmailPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserEmailPatch(apiUserEmailPatchRequest?: ApiUserEmailPatchRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserEmailPatch(apiUserEmailPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify the User Email
         * @param {ApiUserEmailVerifyPostRequest} [apiUserEmailVerifyPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserEmailVerifyPost(apiUserEmailVerifyPostRequest?: ApiUserEmailVerifyPostRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserEmailVerifyPost(apiUserEmailVerifyPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Accept Friend Requests
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsAcceptPost(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: any): AxiosPromise<ApiServerServerFilesDeletePost200Response> {
            return localVarFp.apiUserFriendsAcceptPost(apiServerServerSubusersDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove Friends
         * @param {ApiUserFriendsDeleteRequest} [apiUserFriendsDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsDelete(apiUserFriendsDeleteRequest?: ApiUserFriendsDeleteRequest, options?: any): AxiosPromise<ApiUserFriendsDelete200Response> {
            return localVarFp.apiUserFriendsDelete(apiUserFriendsDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Friends
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsGet(page?: number, search?: string, options?: any): AxiosPromise<ApiUserFriendsGet200Response> {
            return localVarFp.apiUserFriendsGet(page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable Incoming Friend Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsIncomingDisablePost(options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserFriendsIncomingDisablePost(options).then((request) => request(axios, basePath));
        },
        /**
         * Enable Incoming Friend Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsIncomingEnablePost(options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserFriendsIncomingEnablePost(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Pending Friends
         * @param {ApiUserFriendsPendingGetTypeEnum} type The type of pending friends to get
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsPendingGet(type: ApiUserFriendsPendingGetTypeEnum, page?: number, search?: string, options?: any): AxiosPromise<ApiUserFriendsGet200Response> {
            return localVarFp.apiUserFriendsPendingGet(type, page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Accept Friend Request
         * @param {number} user The ID of the friend request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsUserAcceptPost(user: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserFriendsUserAcceptPost(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove Friend
         * @param {number} user The ID of the friend request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFriendsUserDelete(user: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserFriendsUserDelete(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Invoices
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserInvoicesCancelPost(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: any): AxiosPromise<ApiServerServerFilesDeletePost200Response> {
            return localVarFp.apiUserInvoicesCancelPost(apiServerServerSubusersDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Invoices
         * @param {number} [page] 
         * @param {ApiUserInvoicesGetTypeEnum} [type] The type of invoices to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserInvoicesGet(page?: number, type?: ApiUserInvoicesGetTypeEnum, options?: any): AxiosPromise<ApiUserInvoicesGet200Response> {
            return localVarFp.apiUserInvoicesGet(page, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Invoice
         * @param {number} invoice The ID of the invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserInvoicesInvoiceCancelPost(invoice: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserInvoicesInvoiceCancelPost(invoice, options).then((request) => request(axios, basePath));
        },
        /**
         * Pay Invoice
         * @param {number} invoice The ID of the invoice
         * @param {ApiUserInvoicesInvoicePayPostRequest} [apiUserInvoicesInvoicePayPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserInvoicesInvoicePayPost(invoice: number, apiUserInvoicesInvoicePayPostRequest?: ApiUserInvoicesInvoicePayPostRequest, options?: any): AxiosPromise<ApiUserInvoicesInvoicePayPost200Response> {
            return localVarFp.apiUserInvoicesInvoicePayPost(invoice, apiUserInvoicesInvoicePayPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create Invoice
         * @param {ApiUserInvoicesPostRequest} [apiUserInvoicesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserInvoicesPost(apiUserInvoicesPostRequest?: ApiUserInvoicesPostRequest, options?: any): AxiosPromise<ApiUserInvoicesPost200Response> {
            return localVarFp.apiUserInvoicesPost(apiUserInvoicesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Invoice Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserInvoicesStatsGet(options?: any): AxiosPromise<ApiUserInvoicesStatsGet200Response> {
            return localVarFp.apiUserInvoicesStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Login with Two Factor
         * @param {ApiUserLogin2faPostRequest} [apiUserLogin2faPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserLogin2faPost(apiUserLogin2faPostRequest?: ApiUserLogin2faPostRequest, options?: any): AxiosPromise<ApiUserPost200Response> {
            return localVarFp.apiUserLogin2faPost(apiUserLogin2faPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * OAuth2 Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserLoginOauthPost(options?: any): AxiosPromise<ApiUserLoginPost200Response> {
            return localVarFp.apiUserLoginOauthPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Login
         * @param {ApiUserLoginPostRequest} [apiUserLoginPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserLoginPost(apiUserLoginPostRequest?: ApiUserLoginPostRequest, options?: any): AxiosPromise<ApiUserLoginPost200Response> {
            return localVarFp.apiUserLoginPost(apiUserLoginPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserLogoutPost(options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete User
         * @param {ApiUserMeDeleteRequest} [apiUserMeDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserMeDelete(apiUserMeDeleteRequest?: ApiUserMeDeleteRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserMeDelete(apiUserMeDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserMeGet(options?: any): AxiosPromise<ApiUserMeGet200Response> {
            return localVarFp.apiUserMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update User
         * @param {ApiUserMePatchRequest} [apiUserMePatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserMePatch(apiUserMePatchRequest?: ApiUserMePatchRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserMePatch(apiUserMePatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Nodes Autocomplete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesAutocompleteGet(options?: any): AxiosPromise<ApiUserNodesAutocompleteGet200Response> {
            return localVarFp.apiUserNodesAutocompleteGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Nodes
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesGet(page?: number, search?: string, options?: any): AxiosPromise<ApiUserNodesGet200Response> {
            return localVarFp.apiUserNodesGet(page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Node Allocation
         * @param {number} node The ID of the node
         * @param {number} allocation The ID of the allocation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeAllocationsAllocationDelete(node: number, allocation: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserNodesNodeAllocationsAllocationDelete(node, allocation, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Node Allocation
         * @param {number} node The ID of the node
         * @param {number} allocation The ID of the allocation
         * @param {ApiUserNodesNodeAllocationsAllocationPatchRequest} [apiUserNodesNodeAllocationsAllocationPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeAllocationsAllocationPatch(node: number, allocation: number, apiUserNodesNodeAllocationsAllocationPatchRequest?: ApiUserNodesNodeAllocationsAllocationPatchRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserNodesNodeAllocationsAllocationPatch(node, allocation, apiUserNodesNodeAllocationsAllocationPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Node Allocations
         * @param {number} node The ID of the node
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeAllocationsDelete(node: number, apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: any): AxiosPromise<ApiServerServerFilesDeletePost200Response> {
            return localVarFp.apiUserNodesNodeAllocationsDelete(node, apiServerServerSubusersDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Node Allocations
         * @param {number} node The ID of the node
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeAllocationsGet(node: number, page?: number, options?: any): AxiosPromise<ApiUserNodesNodeAllocationsGet200Response> {
            return localVarFp.apiUserNodesNodeAllocationsGet(node, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Create Node Allocation
         * @param {number} node The ID of the node
         * @param {ApiUserNodesNodeAllocationsPostRequest} [apiUserNodesNodeAllocationsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeAllocationsPost(node: number, apiUserNodesNodeAllocationsPostRequest?: ApiUserNodesNodeAllocationsPostRequest, options?: any): AxiosPromise<ApiUserNodesNodeAllocationsPost200Response> {
            return localVarFp.apiUserNodesNodeAllocationsPost(node, apiUserNodesNodeAllocationsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Node
         * @param {number} node The ID of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeDelete(node: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserNodesNodeDelete(node, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Node
         * @param {number} node The ID of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeGet(node: number, options?: any): AxiosPromise<ApiUserNodesPost200Response> {
            return localVarFp.apiUserNodesNodeGet(node, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Node
         * @param {number} node The ID of the node
         * @param {ApiUserNodesNodePatchRequest} [apiUserNodesNodePatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodePatch(node: number, apiUserNodesNodePatchRequest?: ApiUserNodesNodePatchRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserNodesNodePatch(node, apiUserNodesNodePatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset Node Key
         * @param {number} node The ID of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeResetKeyPost(node: number, options?: any): AxiosPromise<ApiUserNodesPost200Response> {
            return localVarFp.apiUserNodesNodeResetKeyPost(node, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Node Stats
         * @param {number} node The ID of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesNodeStatsGet(node: number, options?: any): AxiosPromise<ApiUserNodesNodeStatsGet200Response> {
            return localVarFp.apiUserNodesNodeStatsGet(node, options).then((request) => request(axios, basePath));
        },
        /**
         * Create Node
         * @param {ApiUserNodesPostRequest} [apiUserNodesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserNodesPost(apiUserNodesPostRequest?: ApiUserNodesPostRequest, options?: any): AxiosPromise<ApiUserNodesPost200Response> {
            return localVarFp.apiUserNodesPost(apiUserNodesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register with OAuth
         * @param {ApiUserOauthPostRequest} [apiUserOauthPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserOauthPost(apiUserOauthPostRequest?: ApiUserOauthPostRequest, options?: any): AxiosPromise<ApiUserPost200Response> {
            return localVarFp.apiUserOauthPost(apiUserOauthPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update User Password
         * @param {ApiUserPasswordPatchRequest} [apiUserPasswordPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPasswordPatch(apiUserPasswordPatchRequest?: ApiUserPasswordPatchRequest, options?: any): AxiosPromise<ApiAdminPollsPost200Response> {
            return localVarFp.apiUserPasswordPatch(apiUserPasswordPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset Password
         * @param {ApiUserPasswordResetPatchRequest} [apiUserPasswordResetPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPasswordResetPatch(apiUserPasswordResetPatchRequest?: ApiUserPasswordResetPatchRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserPasswordResetPatch(apiUserPasswordResetPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Request Password Reset
         * @param {ApiUserPasswordResetPostRequest} [apiUserPasswordResetPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPasswordResetPost(apiUserPasswordResetPostRequest?: ApiUserPasswordResetPostRequest, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserPasswordResetPost(apiUserPasswordResetPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Polls
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPollsGet(page?: number, search?: string, options?: any): AxiosPromise<ApiAdminPollsGet200Response> {
            return localVarFp.apiUserPollsGet(page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Poll
         * @param {number} poll The ID of the poll or poll option
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPollsPollGet(poll: number, options?: any): AxiosPromise<ApiPollsPollGet200Response> {
            return localVarFp.apiUserPollsPollGet(poll, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke Vote on Poll
         * @param {number} poll The ID of the poll or poll option
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPollsPollVoteDelete(poll: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserPollsPollVoteDelete(poll, options).then((request) => request(axios, basePath));
        },
        /**
         * Vote on Poll
         * @param {number} poll The ID of the poll or poll option
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPollsPollVotePost(poll: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserPollsPollVotePost(poll, options).then((request) => request(axios, basePath));
        },
        /**
         * Register
         * @param {ApiUserPostRequest} [apiUserPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPost(apiUserPostRequest?: ApiUserPostRequest, options?: any): AxiosPromise<ApiUserPost200Response> {
            return localVarFp.apiUserPost(apiUserPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Servers
         * @param {ApiUserServersGetTypeEnum} type The type of servers to get
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserServersGet(type: ApiUserServersGetTypeEnum, page?: number, search?: string, options?: any): AxiosPromise<ApiUserServersGet200Response> {
            return localVarFp.apiUserServersGet(type, page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Create Server
         * @param {ApiUserServersPostRequest} [apiUserServersPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserServersPost(apiUserServersPostRequest?: ApiUserServersPostRequest, options?: any): AxiosPromise<ApiServerServerGet200Response> {
            return localVarFp.apiUserServersPost(apiUserServersPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Server Templates Autocomplete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserServersTemplatesAutocompleteGet(options?: any): AxiosPromise<ApiUserServersTemplatesAutocompleteGet200Response> {
            return localVarFp.apiUserServersTemplatesAutocompleteGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Server Templates
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserServersTemplatesGet(page?: number, search?: string, options?: any): AxiosPromise<ApiUserServersTemplatesGet200Response> {
            return localVarFp.apiUserServersTemplatesGet(page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete multiple sessions
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSessionsDelete(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: any): AxiosPromise<ApiServerServerFilesDeletePost200Response> {
            return localVarFp.apiUserSessionsDelete(apiServerServerSubusersDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Paginated Sessions
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSessionsGet(page?: number, options?: any): AxiosPromise<ApiUserSessionsGet200Response> {
            return localVarFp.apiUserSessionsGet(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Session
         * @param {number} session The ID of the session to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSessionsSessionDelete(session: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserSessionsSessionDelete(session, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Session
         * @param {number} session The ID of the session to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSessionsSessionGet(session: number, options?: any): AxiosPromise<ApiUserSessionsSessionGet200Response> {
            return localVarFp.apiUserSessionsSessionGet(session, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete SSH Keys
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSshKeysDelete(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: any): AxiosPromise<ApiServerServerFilesDeletePost200Response> {
            return localVarFp.apiUserSshKeysDelete(apiServerServerSubusersDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SSH Keys
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSshKeysGet(page?: number, search?: string, options?: any): AxiosPromise<ApiUserSshKeysGet200Response> {
            return localVarFp.apiUserSshKeysGet(page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Create SSH Key
         * @param {ApiUserSshKeysPostRequest} [apiUserSshKeysPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSshKeysPost(apiUserSshKeysPostRequest?: ApiUserSshKeysPostRequest, options?: any): AxiosPromise<ApiUserSshKeysPost200Response> {
            return localVarFp.apiUserSshKeysPost(apiUserSshKeysPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete SSH Key
         * @param {number} sshKey The ID of the ssh key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSshKeysSshKeyDelete(sshKey: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserSshKeysSshKeyDelete(sshKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Close Tickets
         * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTicketsClosePost(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: any): AxiosPromise<ApiServerServerFilesDeletePost200Response> {
            return localVarFp.apiUserTicketsClosePost(apiServerServerSubusersDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Tickets
         * @param {number} [page] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTicketsGet(page?: number, search?: string, options?: any): AxiosPromise<ApiAdminTicketsGet200Response> {
            return localVarFp.apiUserTicketsGet(page, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Ticket
         * @param {ApiUserTicketsPostRequest} [apiUserTicketsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTicketsPost(apiUserTicketsPostRequest?: ApiUserTicketsPostRequest, options?: any): AxiosPromise<ApiUserTicketsPost200Response> {
            return localVarFp.apiUserTicketsPost(apiUserTicketsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Close Tickets
         * @param {number} ticket The ID of the Ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTicketsTicketClosePost(ticket: number, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserTicketsTicketClosePost(ticket, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Ticket
         * @param {number} ticket The ID of the Ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTicketsTicketGet(ticket: number, options?: any): AxiosPromise<ApiUserTicketsPost200Response> {
            return localVarFp.apiUserTicketsTicketGet(ticket, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Ticket Messages
         * @param {number} ticket The ID of the Ticket
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTicketsTicketMessagesGet(ticket: number, page?: number, options?: any): AxiosPromise<ApiUserTicketsTicketMessagesGet200Response> {
            return localVarFp.apiUserTicketsTicketMessagesGet(ticket, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Send Friend Request
         * @param {string} user The handle of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserUserFriendPost(user: string, options?: any): AxiosPromise<ApiServerServerFilesPullsPullDelete200Response> {
            return localVarFp.apiUserUserFriendPost(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Get User Information
         * @param {string} user The User Handle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserUserGet(user: string, options?: any): AxiosPromise<ApiUserUserGet200Response> {
            return localVarFp.apiUserUserGet(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Get Admin Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiAdminGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiAdminGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Polls
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiAdminPollsGet(page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiAdminPollsGet(page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Poll
     * @param {number} poll The ID of the poll
     * @param {ApiAdminPollsPollPatchRequest} [apiAdminPollsPollPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiAdminPollsPollPatch(poll: number, apiAdminPollsPollPatchRequest?: ApiAdminPollsPollPatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiAdminPollsPollPatch(poll, apiAdminPollsPollPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create Poll
     * @param {ApiAdminPollsPostRequest} [apiAdminPollsPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiAdminPollsPost(apiAdminPollsPostRequest?: ApiAdminPollsPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiAdminPollsPost(apiAdminPollsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Tickets
     * @param {ApiAdminTicketsGetTypeEnum} type The type of tickets to get
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiAdminTicketsGet(type: ApiAdminTicketsGetTypeEnum, page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiAdminTicketsGet(type, page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiHooksOauthDiscordGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiHooksOauthDiscordGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiHooksOauthGithubGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiHooksOauthGithubGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiHooksOauthGoogleGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiHooksOauthGoogleGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiHooksPaypalCancelGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiHooksPaypalCancelGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiHooksPaypalReturnGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiHooksPaypalReturnGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Global Infos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiInfosGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiInfosGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Node Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiNodeInfosGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiNodeInfosGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server Allocations
     * @param {number} server The ID of the server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiNodeServerServerAllocationsGet(server: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiNodeServerServerAllocationsGet(server, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Archive Status
     * @param {number} server The ID of the server
     * @param {ApiNodeServerServerFilesPullPostRequest} [apiNodeServerServerFilesPullPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiNodeServerServerFilesArchivePost(server: number, apiNodeServerServerFilesPullPostRequest?: ApiNodeServerServerFilesPullPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiNodeServerServerFilesArchivePost(server, apiNodeServerServerFilesPullPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Pull Status
     * @param {number} server The ID of the server
     * @param {ApiNodeServerServerFilesPullPostRequest} [apiNodeServerServerFilesPullPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiNodeServerServerFilesPullPost(server: number, apiNodeServerServerFilesPullPostRequest?: ApiNodeServerServerFilesPullPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiNodeServerServerFilesPullPost(server, apiNodeServerServerFilesPullPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate Server SSH Credentials
     * @param {number} server The ID of the server
     * @param {ApiNodeServerServerSshPostRequest} [apiNodeServerServerSshPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiNodeServerServerSshPost(server: number, apiNodeServerServerSshPostRequest?: ApiNodeServerServerSshPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiNodeServerServerSshPost(server, apiNodeServerServerSshPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Server State
     * @param {number} server The ID of the server
     * @param {ApiNodeServerServerStatePostRequest} [apiNodeServerServerStatePostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiNodeServerServerStatePost(server: number, apiNodeServerServerStatePostRequest?: ApiNodeServerServerStatePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiNodeServerServerStatePost(server, apiNodeServerServerStatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get OpenAPI Docs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiOpenapiGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiOpenapiGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all available permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiPermissionsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiPermissionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Polls
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiPollsGet(page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiPollsGet(page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Poll
     * @param {number} poll The Poll ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiPollsPollGet(poll: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiPollsPollGet(poll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server Actions
     * @param {number} server The ID of the server
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerActionLogsGet(server: number, page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerActionLogsGet(server, page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Server Allocation
     * @param {number} server The ID of the server
     * @param {number} allocation The ID of the allocation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerAllocationsAllocationDelete(server: number, allocation: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerAllocationsAllocationDelete(server, allocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Server Allocation
     * @param {number} server The ID of the server
     * @param {number} allocation The ID of the allocation
     * @param {ApiServerServerAllocationsAllocationPatchRequest} [apiServerServerAllocationsAllocationPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerAllocationsAllocationPatch(server: number, allocation: number, apiServerServerAllocationsAllocationPatchRequest?: ApiServerServerAllocationsAllocationPatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerAllocationsAllocationPatch(server, allocation, apiServerServerAllocationsAllocationPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server Node Allocations Autocomplete
     * @param {number} server The ID of the server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerAllocationsAutocompleteGet(server: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerAllocationsAutocompleteGet(server, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Server Allocations
     * @param {number} server The ID of the server
     * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerAllocationsDelete(server: number, apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerAllocationsDelete(server, apiServerServerSubusersDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server Allocations
     * @param {number} server The ID of the server
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerAllocationsGet(server: number, page?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerAllocationsGet(server, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create Server Allocation
     * @param {number} server The ID of the server
     * @param {ApiServerServerAllocationsPostRequest} [apiServerServerAllocationsPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerAllocationsPost(server: number, apiServerServerAllocationsPostRequest?: ApiServerServerAllocationsPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerAllocationsPost(server, apiServerServerAllocationsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Server
     * @param {number} server The ID of the server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerDelete(server: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerDelete(server, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Abort Server File Archive Operation
     * @param {number} server The ID of the server
     * @param {number} archive The ID of the archive operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerFilesArchivesArchiveDelete(server: number, archive: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerFilesArchivesArchiveDelete(server, archive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server Archive Operations
     * @param {number} server The ID of the server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerFilesArchivesGet(server: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerFilesArchivesGet(server, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archive Server Files
     * @param {number} server The ID of the server
     * @param {string} path The path to the file or directory
     * @param {ApiServerServerFilesArchivesPostRequest} [apiServerServerFilesArchivesPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerFilesArchivesPost(server: number, path: string, apiServerServerFilesArchivesPostRequest?: ApiServerServerFilesArchivesPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerFilesArchivesPost(server, path, apiServerServerFilesArchivesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Server Files
     * @param {number} server The ID of the server
     * @param {ApiServerServerFilesDeletePostRequest} [apiServerServerFilesDeletePostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerFilesDeletePost(server: number, apiServerServerFilesDeletePostRequest?: ApiServerServerFilesDeletePostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerFilesDeletePost(server, apiServerServerFilesDeletePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server Files
     * @param {number} server The ID of the server
     * @param {string} path The path to the file or directory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerFilesGet(server: number, path: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerFilesGet(server, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server File Hashes
     * @param {number} server The ID of the server
     * @param {string} path The path to the file or directory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerFilesHashGet(server: number, path: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerFilesHashGet(server, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server File Pulls
     * @param {number} server The ID of the server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerFilesPullsGet(server: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerFilesPullsGet(server, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pull Server File
     * @param {number} server The ID of the server
     * @param {string} path The path to the file or directory
     * @param {ApiServerServerFilesPullsPostRequest} [apiServerServerFilesPullsPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerFilesPullsPost(server: number, path: string, apiServerServerFilesPullsPostRequest?: ApiServerServerFilesPullsPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerFilesPullsPost(server, path, apiServerServerFilesPullsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Abort Server File Pull
     * @param {number} server The ID of the server
     * @param {number} pull The ID of the pull
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerFilesPullsPullDelete(server: number, pull: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerFilesPullsPullDelete(server, pull, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server
     * @param {number} server The ID of the server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerGet(server: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerGet(server, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Server Icon
     * @param {number} server The ID of the server
     * @param {File} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerIconPost(server: number, body?: File, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerIconPost(server, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Server
     * @param {number} server The ID of the server
     * @param {ApiServerServerPatchRequest} [apiServerServerPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerPatch(server: number, apiServerServerPatchRequest?: ApiServerServerPatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerPatch(server, apiServerServerPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Server Disk
     * @param {number} server The ID of the server
     * @param {ApiServerServerResourcesDiskPatchRequest} [apiServerServerResourcesDiskPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerResourcesDiskPatch(server: number, apiServerServerResourcesDiskPatchRequest?: ApiServerServerResourcesDiskPatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerResourcesDiskPatch(server, apiServerServerResourcesDiskPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Server Resources
     * @param {number} server The ID of the server
     * @param {ApiServerServerResourcesPatchRequest} [apiServerServerResourcesPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerResourcesPatch(server: number, apiServerServerResourcesPatchRequest?: ApiServerServerResourcesPatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerResourcesPatch(server, apiServerServerResourcesPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server SSH Info
     * @param {number} server The ID of the server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerSshGet(server: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerSshGet(server, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server Stats
     * @param {number} server The ID of the server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerStatsGet(server: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerStatsGet(server, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Server Status
     * @param {number} server The ID of the server
     * @param {ApiServerServerStatusPostRequest} [apiServerServerStatusPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerStatusPost(server: number, apiServerServerStatusPostRequest?: ApiServerServerStatusPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerStatusPost(server, apiServerServerStatusPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Subusers
     * @param {number} server The ID of the server
     * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerSubusersDelete(server: number, apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerSubusersDelete(server, apiServerServerSubusersDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Subusers
     * @param {number} server The ID of the server
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerSubusersGet(server: number, page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerSubusersGet(server, page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create Subuser
     * @param {number} server The ID of the server
     * @param {ApiServerServerSubusersPostRequest} [apiServerServerSubusersPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerSubusersPost(server: number, apiServerServerSubusersPostRequest?: ApiServerServerSubusersPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerSubusersPost(server, apiServerServerSubusersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Subuser
     * @param {number} server The ID of the server
     * @param {number} subuser The ID of the subuser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerSubusersSubuserDelete(server: number, subuser: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerSubusersSubuserDelete(server, subuser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Subuser
     * @param {number} server The ID of the server
     * @param {number} subuser The ID of the subuser
     * @param {ApiServerServerSubusersSubuserPatchRequest} [apiServerServerSubusersSubuserPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiServerServerSubusersSubuserPatch(server: number, subuser: number, apiServerServerSubusersSubuserPatchRequest?: ApiServerServerSubusersSubuserPatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiServerServerSubusersSubuserPatch(server, subuser, apiServerServerSubusersSubuserPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable 2FA on the account
     * @param {ApiUser2faDeleteRequest} [apiUser2faDeleteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUser2faDelete(apiUser2faDeleteRequest?: ApiUser2faDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUser2faDelete(apiUser2faDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUser2faGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUser2faGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable 2FA
     * @param {ApiUser2faPostRequest} [apiUser2faPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUser2faPost(apiUser2faPostRequest?: ApiUser2faPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUser2faPost(apiUser2faPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Account Actions
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserActionLogsGet(page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserActionLogsGet(page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete API Key
     * @param {number} apiKey The ID of the api key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserApiKeysApiKeyDelete(apiKey: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserApiKeysApiKeyDelete(apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update API Key
     * @param {number} apiKey The ID of the api key
     * @param {ApiUserApiKeysApiKeyPatchRequest} [apiUserApiKeysApiKeyPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserApiKeysApiKeyPatch(apiKey: number, apiUserApiKeysApiKeyPatchRequest?: ApiUserApiKeysApiKeyPatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserApiKeysApiKeyPatch(apiKey, apiUserApiKeysApiKeyPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset API Key
     * @param {number} apiKey The ID of the api key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserApiKeysApiKeyResetKeyPost(apiKey: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserApiKeysApiKeyResetKeyPost(apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete API Keys
     * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserApiKeysDelete(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserApiKeysDelete(apiServerServerSubusersDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get API Keys
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserApiKeysGet(page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserApiKeysGet(page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create API Key
     * @param {ApiUserApiKeysPostRequest} [apiUserApiKeysPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserApiKeysPost(apiUserApiKeysPostRequest?: ApiUserApiKeysPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserApiKeysPost(apiUserApiKeysPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update User Avatar
     * @param {File} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserAvatarPost(body?: File, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserAvatarPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove Connection
     * @param {ApiUserConnectionsAppDeleteAppEnum} app The app to remove the connection from
     * @param {ApiUserConnectionsAppDeleteRequest} [apiUserConnectionsAppDeleteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserConnectionsAppDelete(app: ApiUserConnectionsAppDeleteAppEnum, apiUserConnectionsAppDeleteRequest?: ApiUserConnectionsAppDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserConnectionsAppDelete(app, apiUserConnectionsAppDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Connection Infos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserConnectionsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserConnectionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the User Email
     * @param {ApiUserEmailPatchRequest} [apiUserEmailPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserEmailPatch(apiUserEmailPatchRequest?: ApiUserEmailPatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserEmailPatch(apiUserEmailPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify the User Email
     * @param {ApiUserEmailVerifyPostRequest} [apiUserEmailVerifyPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserEmailVerifyPost(apiUserEmailVerifyPostRequest?: ApiUserEmailVerifyPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserEmailVerifyPost(apiUserEmailVerifyPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accept Friend Requests
     * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserFriendsAcceptPost(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserFriendsAcceptPost(apiServerServerSubusersDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove Friends
     * @param {ApiUserFriendsDeleteRequest} [apiUserFriendsDeleteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserFriendsDelete(apiUserFriendsDeleteRequest?: ApiUserFriendsDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserFriendsDelete(apiUserFriendsDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Friends
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserFriendsGet(page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserFriendsGet(page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable Incoming Friend Requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserFriendsIncomingDisablePost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserFriendsIncomingDisablePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable Incoming Friend Requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserFriendsIncomingEnablePost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserFriendsIncomingEnablePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Pending Friends
     * @param {ApiUserFriendsPendingGetTypeEnum} type The type of pending friends to get
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserFriendsPendingGet(type: ApiUserFriendsPendingGetTypeEnum, page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserFriendsPendingGet(type, page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accept Friend Request
     * @param {number} user The ID of the friend request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserFriendsUserAcceptPost(user: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserFriendsUserAcceptPost(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove Friend
     * @param {number} user The ID of the friend request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserFriendsUserDelete(user: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserFriendsUserDelete(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Invoices
     * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserInvoicesCancelPost(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserInvoicesCancelPost(apiServerServerSubusersDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Invoices
     * @param {number} [page] 
     * @param {ApiUserInvoicesGetTypeEnum} [type] The type of invoices to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserInvoicesGet(page?: number, type?: ApiUserInvoicesGetTypeEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserInvoicesGet(page, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Invoice
     * @param {number} invoice The ID of the invoice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserInvoicesInvoiceCancelPost(invoice: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserInvoicesInvoiceCancelPost(invoice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pay Invoice
     * @param {number} invoice The ID of the invoice
     * @param {ApiUserInvoicesInvoicePayPostRequest} [apiUserInvoicesInvoicePayPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserInvoicesInvoicePayPost(invoice: number, apiUserInvoicesInvoicePayPostRequest?: ApiUserInvoicesInvoicePayPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserInvoicesInvoicePayPost(invoice, apiUserInvoicesInvoicePayPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create Invoice
     * @param {ApiUserInvoicesPostRequest} [apiUserInvoicesPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserInvoicesPost(apiUserInvoicesPostRequest?: ApiUserInvoicesPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserInvoicesPost(apiUserInvoicesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Invoice Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserInvoicesStatsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserInvoicesStatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login with Two Factor
     * @param {ApiUserLogin2faPostRequest} [apiUserLogin2faPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserLogin2faPost(apiUserLogin2faPostRequest?: ApiUserLogin2faPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserLogin2faPost(apiUserLogin2faPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OAuth2 Login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserLoginOauthPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserLoginOauthPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login
     * @param {ApiUserLoginPostRequest} [apiUserLoginPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserLoginPost(apiUserLoginPostRequest?: ApiUserLoginPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserLoginPost(apiUserLoginPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserLogoutPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete User
     * @param {ApiUserMeDeleteRequest} [apiUserMeDeleteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserMeDelete(apiUserMeDeleteRequest?: ApiUserMeDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserMeDelete(apiUserMeDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserMeGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update User
     * @param {ApiUserMePatchRequest} [apiUserMePatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserMePatch(apiUserMePatchRequest?: ApiUserMePatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserMePatch(apiUserMePatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Nodes Autocomplete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserNodesAutocompleteGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserNodesAutocompleteGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Nodes
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserNodesGet(page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserNodesGet(page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Node Allocation
     * @param {number} node The ID of the node
     * @param {number} allocation The ID of the allocation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserNodesNodeAllocationsAllocationDelete(node: number, allocation: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserNodesNodeAllocationsAllocationDelete(node, allocation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Node Allocation
     * @param {number} node The ID of the node
     * @param {number} allocation The ID of the allocation
     * @param {ApiUserNodesNodeAllocationsAllocationPatchRequest} [apiUserNodesNodeAllocationsAllocationPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserNodesNodeAllocationsAllocationPatch(node: number, allocation: number, apiUserNodesNodeAllocationsAllocationPatchRequest?: ApiUserNodesNodeAllocationsAllocationPatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserNodesNodeAllocationsAllocationPatch(node, allocation, apiUserNodesNodeAllocationsAllocationPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Node Allocations
     * @param {number} node The ID of the node
     * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserNodesNodeAllocationsDelete(node: number, apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserNodesNodeAllocationsDelete(node, apiServerServerSubusersDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Node Allocations
     * @param {number} node The ID of the node
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserNodesNodeAllocationsGet(node: number, page?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserNodesNodeAllocationsGet(node, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create Node Allocation
     * @param {number} node The ID of the node
     * @param {ApiUserNodesNodeAllocationsPostRequest} [apiUserNodesNodeAllocationsPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserNodesNodeAllocationsPost(node: number, apiUserNodesNodeAllocationsPostRequest?: ApiUserNodesNodeAllocationsPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserNodesNodeAllocationsPost(node, apiUserNodesNodeAllocationsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Node
     * @param {number} node The ID of the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserNodesNodeDelete(node: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserNodesNodeDelete(node, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Node
     * @param {number} node The ID of the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserNodesNodeGet(node: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserNodesNodeGet(node, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Node
     * @param {number} node The ID of the node
     * @param {ApiUserNodesNodePatchRequest} [apiUserNodesNodePatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserNodesNodePatch(node: number, apiUserNodesNodePatchRequest?: ApiUserNodesNodePatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserNodesNodePatch(node, apiUserNodesNodePatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset Node Key
     * @param {number} node The ID of the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserNodesNodeResetKeyPost(node: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserNodesNodeResetKeyPost(node, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Node Stats
     * @param {number} node The ID of the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserNodesNodeStatsGet(node: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserNodesNodeStatsGet(node, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create Node
     * @param {ApiUserNodesPostRequest} [apiUserNodesPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserNodesPost(apiUserNodesPostRequest?: ApiUserNodesPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserNodesPost(apiUserNodesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register with OAuth
     * @param {ApiUserOauthPostRequest} [apiUserOauthPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserOauthPost(apiUserOauthPostRequest?: ApiUserOauthPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserOauthPost(apiUserOauthPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update User Password
     * @param {ApiUserPasswordPatchRequest} [apiUserPasswordPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserPasswordPatch(apiUserPasswordPatchRequest?: ApiUserPasswordPatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserPasswordPatch(apiUserPasswordPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset Password
     * @param {ApiUserPasswordResetPatchRequest} [apiUserPasswordResetPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserPasswordResetPatch(apiUserPasswordResetPatchRequest?: ApiUserPasswordResetPatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserPasswordResetPatch(apiUserPasswordResetPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request Password Reset
     * @param {ApiUserPasswordResetPostRequest} [apiUserPasswordResetPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserPasswordResetPost(apiUserPasswordResetPostRequest?: ApiUserPasswordResetPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserPasswordResetPost(apiUserPasswordResetPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Polls
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserPollsGet(page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserPollsGet(page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Poll
     * @param {number} poll The ID of the poll or poll option
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserPollsPollGet(poll: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserPollsPollGet(poll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke Vote on Poll
     * @param {number} poll The ID of the poll or poll option
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserPollsPollVoteDelete(poll: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserPollsPollVoteDelete(poll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Vote on Poll
     * @param {number} poll The ID of the poll or poll option
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserPollsPollVotePost(poll: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserPollsPollVotePost(poll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register
     * @param {ApiUserPostRequest} [apiUserPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserPost(apiUserPostRequest?: ApiUserPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserPost(apiUserPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Servers
     * @param {ApiUserServersGetTypeEnum} type The type of servers to get
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserServersGet(type: ApiUserServersGetTypeEnum, page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserServersGet(type, page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create Server
     * @param {ApiUserServersPostRequest} [apiUserServersPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserServersPost(apiUserServersPostRequest?: ApiUserServersPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserServersPost(apiUserServersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server Templates Autocomplete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserServersTemplatesAutocompleteGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserServersTemplatesAutocompleteGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Server Templates
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserServersTemplatesGet(page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserServersTemplatesGet(page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete multiple sessions
     * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserSessionsDelete(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserSessionsDelete(apiServerServerSubusersDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Paginated Sessions
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserSessionsGet(page?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserSessionsGet(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Session
     * @param {number} session The ID of the session to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserSessionsSessionDelete(session: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserSessionsSessionDelete(session, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Session
     * @param {number} session The ID of the session to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserSessionsSessionGet(session: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserSessionsSessionGet(session, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete SSH Keys
     * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserSshKeysDelete(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserSshKeysDelete(apiServerServerSubusersDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SSH Keys
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserSshKeysGet(page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserSshKeysGet(page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create SSH Key
     * @param {ApiUserSshKeysPostRequest} [apiUserSshKeysPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserSshKeysPost(apiUserSshKeysPostRequest?: ApiUserSshKeysPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserSshKeysPost(apiUserSshKeysPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete SSH Key
     * @param {number} sshKey The ID of the ssh key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserSshKeysSshKeyDelete(sshKey: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserSshKeysSshKeyDelete(sshKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close Tickets
     * @param {ApiServerServerSubusersDeleteRequest} [apiServerServerSubusersDeleteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserTicketsClosePost(apiServerServerSubusersDeleteRequest?: ApiServerServerSubusersDeleteRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserTicketsClosePost(apiServerServerSubusersDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Tickets
     * @param {number} [page] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserTicketsGet(page?: number, search?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserTicketsGet(page, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Ticket
     * @param {ApiUserTicketsPostRequest} [apiUserTicketsPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserTicketsPost(apiUserTicketsPostRequest?: ApiUserTicketsPostRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserTicketsPost(apiUserTicketsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close Tickets
     * @param {number} ticket The ID of the Ticket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserTicketsTicketClosePost(ticket: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserTicketsTicketClosePost(ticket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Ticket
     * @param {number} ticket The ID of the Ticket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserTicketsTicketGet(ticket: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserTicketsTicketGet(ticket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Ticket Messages
     * @param {number} ticket The ID of the Ticket
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserTicketsTicketMessagesGet(ticket: number, page?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserTicketsTicketMessagesGet(ticket, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send Friend Request
     * @param {string} user The handle of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserUserFriendPost(user: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserUserFriendPost(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get User Information
     * @param {string} user The User Handle
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiUserUserGet(user: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiUserUserGet(user, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ApiAdminTicketsGetTypeEnum = {
    Open: 'open',
    Closed: 'closed',
    Both: 'both'
} as const;
export type ApiAdminTicketsGetTypeEnum = typeof ApiAdminTicketsGetTypeEnum[keyof typeof ApiAdminTicketsGetTypeEnum];
/**
 * @export
 */
export const ApiUserConnectionsAppDeleteAppEnum = {
    Google: 'GOOGLE',
    Github: 'GITHUB',
    Discord: 'DISCORD'
} as const;
export type ApiUserConnectionsAppDeleteAppEnum = typeof ApiUserConnectionsAppDeleteAppEnum[keyof typeof ApiUserConnectionsAppDeleteAppEnum];
/**
 * @export
 */
export const ApiUserFriendsPendingGetTypeEnum = {
    Both: 'both',
    Incoming: 'incoming',
    Outgoing: 'outgoing'
} as const;
export type ApiUserFriendsPendingGetTypeEnum = typeof ApiUserFriendsPendingGetTypeEnum[keyof typeof ApiUserFriendsPendingGetTypeEnum];
/**
 * @export
 */
export const ApiUserInvoicesGetTypeEnum = {
    Both: 'both',
    Incoming: 'incoming',
    Outgoing: 'outgoing'
} as const;
export type ApiUserInvoicesGetTypeEnum = typeof ApiUserInvoicesGetTypeEnum[keyof typeof ApiUserInvoicesGetTypeEnum];
/**
 * @export
 */
export const ApiUserServersGetTypeEnum = {
    Both: 'both',
    Owner: 'owner',
    Subuser: 'subuser'
} as const;
export type ApiUserServersGetTypeEnum = typeof ApiUserServersGetTypeEnum[keyof typeof ApiUserServersGetTypeEnum];


